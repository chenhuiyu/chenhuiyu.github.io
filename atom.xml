<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黑头呆鱼进化之旅</title>
  
  <subtitle>只身打码过草原</subtitle>
  <link href="https://chenhuiyu.github.io/atom.xml" rel="self"/>
  
  <link href="https://chenhuiyu.github.io/"/>
  <updated>2024-02-26T06:29:53.822Z</updated>
  <id>https://chenhuiyu.github.io/</id>
  
  <author>
    <name>Huiyu Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>英语学习日记：De Facto</title>
    <link href="https://chenhuiyu.github.io/2024/02/26/Life%20Reflections/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%9ADe%20Facto/"/>
    <id>https://chenhuiyu.github.io/2024/02/26/Life%20Reflections/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%9ADe%20Facto/</id>
    <published>2024-02-26T06:29:00.000Z</published>
    <updated>2024-02-26T06:29:53.822Z</updated>
    
    <content type="html"><![CDATA[<p>大家好！🌐 今天我们要探讨一个在英语对话和写作中常见的短语：<strong>de facto</strong></p><h3 id="理解-“De-Facto”"><a href="#理解-“De-Facto”" class="headerlink" title="理解 “De Facto”"></a>理解 “De Facto”</h3><ol><li><p><strong>含义</strong>：’De facto’ 这个短语用来描述一些实际上存在的事物，即使它们没有被官方认可或法律确立。就像是在说“实际上”或“实践中”，而不是“理论上”或“官方上”。</p></li><li><p><strong>词源</strong>：这个短语有着非常有趣的历史。它源自拉丁语，其中 ‘de’ 意为 ‘来自’，’facto’ 意味着 ‘事实’。随着时间的推移，它被英语采纳，并保留了从拉丁语中原始的精髓。</p></li></ol><h3 id="例句"><a href="#例句" class="headerlink" title="例句"></a>例句</h3><ul><li>🌟 <em>In many organizations, there is a <strong>de facto</strong> leader who isn’t officially the boss but is respected and followed by the team.</em></li><li>🌟 <em>While English is the <strong>de facto</strong> language of international business, it’s not the official language in many countries where it’s widely spoken.</em></li><li>🌟 <em>The museum, though not formally recognized, acts as the <strong>de facto</strong> cultural center of the small town.</em></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>‘De facto’ 这个术语是一种微妙但强大的方式，用来描述情况的现实，区别于其官方或法律地位。将这样的短语纳入你的语言库不仅丰富了你的词汇，还增强了你表达细微想法的能力。继续探索并拥抱语言的美妙吧！📚💬</p><p>记住，语言是一段旅程，不是终点。祝学习愉快，我们下次见！🚀🌟</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家好！🌐 今天我们要探讨一个在英语对话和写作中常见的短语：&lt;strong&gt;de facto&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;理解-“De-Facto”&quot;&gt;&lt;a href=&quot;#理解-“De-Facto”&quot; class=&quot;headerlink&quot; title=&quot;理解</summary>
      
    
    
    
    <category term="Life Reflections" scheme="https://chenhuiyu.github.io/categories/Life-Reflections/"/>
    
    
    <category term="Language Learning" scheme="https://chenhuiyu.github.io/tags/Language-Learning/"/>
    
    <category term="English Vocabulary" scheme="https://chenhuiyu.github.io/tags/English-Vocabulary/"/>
    
  </entry>
  
  <entry>
    <title>De Facto: Unveiling the Power of an Intriguing Phrase</title>
    <link href="https://chenhuiyu.github.io/2024/02/26/Life%20Reflections/De%20Facto:%20Unveiling%20the%20Power%20of%20an%20Intriguing%20Phrase%20/"/>
    <id>https://chenhuiyu.github.io/2024/02/26/Life%20Reflections/De%20Facto:%20Unveiling%20the%20Power%20of%20an%20Intriguing%20Phrase%20/</id>
    <published>2024-02-26T06:25:00.000Z</published>
    <updated>2024-02-26T06:29:42.776Z</updated>
    
    <content type="html"><![CDATA[<p>Hello, language enthusiasts! 🌐 Today, we’re diving into a fascinating phrase that often pops up in English conversations and writings: <strong>de facto</strong>. Let’s explore its meaning, origins, and how to use it effectively in sentences. Whether you’re a language learner or a word nerd, you’ll find this exploration both enlightening and fun! ✨</p><h3 id="Understanding-“De-Facto”"><a href="#Understanding-“De-Facto”" class="headerlink" title="Understanding “De Facto”"></a>Understanding “De Facto”</h3><ol><li><p><strong>Meaning</strong>: The term ‘de facto’ is used to describe something that exists in reality, even if it’s not officially recognized or legally established. It’s like saying “in practice” or “in actuality,” as opposed to “in theory” or “officially.”</p></li><li><p><strong>Origins</strong>: This phrase has an interesting journey. It comes from Latin, where ‘de’ means ‘from’ and ‘facto’ means ‘fact.’ Over time, it’s been adopted into English, retaining its original essence from Latin.</p></li></ol><h3 id="Examples-in-Sentences"><a href="#Examples-in-Sentences" class="headerlink" title="Examples in Sentences"></a>Examples in Sentences</h3><ul><li>🌟 <em>In many organizations, there is a <strong>de facto</strong> leader who isn’t officially the boss but is respected and followed by the team.</em></li><li>🌟 <em>While English is the <strong>de facto</strong> language of international business, it’s not the official language in many countries where it’s widely spoken.</em></li><li>🌟 <em>The museum, though not formally recognized, acts as the <strong>de facto</strong> cultural center of the small town.</em></li></ul><h3 id="Wrapping-Up"><a href="#Wrapping-Up" class="headerlink" title="Wrapping Up"></a>Wrapping Up</h3><p>The term ‘de facto’ is a subtle but powerful way to describe the reality of a situation, distinguishing it from its official or legal status. Incorporating such phrases into your language arsenal not only enriches your vocabulary but also enhances your ability to express nuanced ideas. Keep exploring and embracing the beauty of language! 📚💬</p><p>Remember, language is a journey, not a destination. Happy learning, and see you in the next post! 🚀🌟</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hello, language enthusiasts! 🌐 Today, we’re diving into a fascinating phrase that often pops up in English conversations and writings: &lt;</summary>
      
    
    
    
    <category term="Life Reflections" scheme="https://chenhuiyu.github.io/categories/Life-Reflections/"/>
    
    
    <category term="Language Learning" scheme="https://chenhuiyu.github.io/tags/Language-Learning/"/>
    
    <category term="English Vocabulary" scheme="https://chenhuiyu.github.io/tags/English-Vocabulary/"/>
    
  </entry>
  
  <entry>
    <title>英语学习日记：探索金融术语 &#39;Giro Date&#39;</title>
    <link href="https://chenhuiyu.github.io/2024/02/21/Life%20Reflections/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%9A%E6%8E%A2%E7%B4%A2%E9%87%91%E8%9E%8D%E6%9C%AF%E8%AF%AD%20&#39;Giro%20Date&#39;/"/>
    <id>https://chenhuiyu.github.io/2024/02/21/Life%20Reflections/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%9A%E6%8E%A2%E7%B4%A2%E9%87%91%E8%9E%8D%E6%9C%AF%E8%AF%AD%20&#39;Giro%20Date&#39;/</id>
    <published>2024-02-21T07:33:00.000Z</published>
    <updated>2024-02-21T07:34:04.140Z</updated>
    
    <content type="html"><![CDATA[<p>今天的英语学习之旅中，我遇到了一个有趣的金融术语：“Giro date”。这个探索过程不仅丰富了我的词汇，还加深了我对英语中金融概念的理解。让我和你分享一下我是如何分析这个术语及其在金融世界中的重要性。</p><h3 id="发现词源-🌍"><a href="#发现词源-🌍" class="headerlink" title="发现词源 🌍"></a>发现词源 🌍</h3><ul><li><strong>意大利语根源</strong>: 我的研究发现 ‘Giro’ 来自意大利语单词 “girare”，意味着转账或支付。</li><li><strong>金融语境</strong>: 在金融领域中，’giro’ 通常指的是通过银行或其他金融机构的转账。</li></ul><h3 id="学习其用法-💡"><a href="#学习其用法-💡" class="headerlink" title="学习其用法 💡"></a>学习其用法 💡</h3><ul><li><strong>定义</strong>: 在金融交易中，’Giro date’ 特指支付或结算日期。</li><li><strong>银行业重要性</strong>: 这是一个预定的日期，资金预期在此日期被支付或结算。</li></ul><h3 id="实际应用-📘"><a href="#实际应用-📘" class="headerlink" title="实际应用 📘"></a>实际应用 📘</h3><ul><li><strong>发票支付日期</strong>: “Please ensure that the giro date for the invoice is set to the 25th of this month.”（请确保发票的支付日期设为本月25日。）</li><li><strong>贷款还款日期</strong>: “The giro date for the loan repayment is automatically set for the 1st of each month.”（贷款还款的支付日期自动设定为每月的第一天。）</li></ul><p>这些例子帮助我巩固了对这个术语的理解，展示了它在银行业务、财务管理和账务处理中的用途。</p><h3 id="反思与前行-🌟"><a href="#反思与前行-🌟" class="headerlink" title="反思与前行 🌟"></a>反思与前行 🌟</h3><p>随我继续在英语学习的迷人世界中旅行，每一个术语都解锁了新的知识和理解！📚✨</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天的英语学习之旅中，我遇到了一个有趣的金融术语：“Giro date”。这个探索过程不仅丰富了我的词汇，还加深了我对英语中金融概念的理解。让我和你分享一下我是如何分析这个术语及其在金融世界中的重要性。&lt;/p&gt;
&lt;h3 id=&quot;发现词源-🌍&quot;&gt;&lt;a href=&quot;#发现词源</summary>
      
    
    
    
    <category term="Life Reflections" scheme="https://chenhuiyu.github.io/categories/Life-Reflections/"/>
    
    
    <category term="Language Learning" scheme="https://chenhuiyu.github.io/tags/Language-Learning/"/>
    
    <category term="English Vocabulary" scheme="https://chenhuiyu.github.io/tags/English-Vocabulary/"/>
    
  </entry>
  
  <entry>
    <title>English Learning Journey: Unraveling the Term &#39;Giro Date&#39;</title>
    <link href="https://chenhuiyu.github.io/2024/02/21/Life%20Reflections/English%20Learning%20Journey:%20Unraveling%20the%20Term%20&#39;Giro%20Date&#39;/"/>
    <id>https://chenhuiyu.github.io/2024/02/21/Life%20Reflections/English%20Learning%20Journey:%20Unraveling%20the%20Term%20&#39;Giro%20Date&#39;/</id>
    <published>2024-02-21T07:32:00.000Z</published>
    <updated>2024-02-21T10:47:41.097Z</updated>
    
    <content type="html"><![CDATA[<p>Today in my English learning journey, I encountered an intriguing financial term: “Giro date”. This exploration not only expanded my vocabulary but also deepened my understanding of financial concepts in English. Let me share with you how I dissected this term and its relevance in the financial world.</p><h3 id="Discovering-the-Origin-🌍"><a href="#Discovering-the-Origin-🌍" class="headerlink" title="Discovering the Origin 🌍"></a>Discovering the Origin 🌍</h3><ul><li><strong>Italian Roots</strong>: My research revealed that ‘Giro’ originates from the Italian word “girare,” meaning to transfer or pay. </li><li><strong>Financial Context</strong>: In the realm of finance, ‘giro’ typically refers to a bank or institutional transfer.</li></ul><h3 id="Learning-the-Usage-💡"><a href="#Learning-the-Usage-💡" class="headerlink" title="Learning the Usage 💡"></a>Learning the Usage 💡</h3><ul><li><strong>Definition</strong>: In financial transactions, ‘Giro date’ specifically denotes the payment or settlement date.</li><li><strong>Banking Significance</strong>: It’s a predetermined date when funds are expected to be paid or settled.</li></ul><h3 id="Applying-it-in-Context-📘"><a href="#Applying-it-in-Context-📘" class="headerlink" title="Applying it in Context 📘"></a>Applying it in Context 📘</h3><ul><li><strong>Invoice Payment Date</strong>: I practiced using the term in a sentence: “Please ensure that the giro date for the invoice is set to the 25th of this month.”</li><li><strong>Loan Repayment Date</strong>: Another example I came up with was, “The giro date for the loan repayment is automatically set for the 1st of each month.”</li></ul><p>These examples helped cement the term in my mind, illustrating its use in banking, financial management, and account processing.</p><h3 id="Reflections-and-Forward-Steps-🌟"><a href="#Reflections-and-Forward-Steps-🌟" class="headerlink" title="Reflections and Forward Steps 🌟"></a>Reflections and Forward Steps 🌟</h3><p>Understanding ‘Giro date’ was not just about adding a new word to my vocabulary; it was about comprehending a concept that plays a vital role in financial transactions. This learning experience has made me appreciate the nuances of financial English and motivated me to delve deeper into industry-specific terminology.</p><p>Join me as I continue my journey through the fascinating world of English language learning, where every term unlocks new knowledge and understanding! 📚✨</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Today in my English learning journey, I encountered an intriguing financial term: “Giro date”. This exploration not only expanded my voca</summary>
      
    
    
    
    <category term="Life Reflections" scheme="https://chenhuiyu.github.io/categories/Life-Reflections/"/>
    
    
    <category term="Language Learning" scheme="https://chenhuiyu.github.io/tags/Language-Learning/"/>
    
    <category term="English Vocabulary" scheme="https://chenhuiyu.github.io/tags/English-Vocabulary/"/>
    
  </entry>
  
  <entry>
    <title>How to Resolve SSH Key Issues with Multiple Git Services</title>
    <link href="https://chenhuiyu.github.io/2024/02/19/Debugging%20Diaries/How%20to%20Resolve%20SSH%20Key%20Issues%20with%20Multiple%20Git%20Services/"/>
    <id>https://chenhuiyu.github.io/2024/02/19/Debugging%20Diaries/How%20to%20Resolve%20SSH%20Key%20Issues%20with%20Multiple%20Git%20Services/</id>
    <published>2024-02-19T07:49:55.000Z</published>
    <updated>2024-02-19T07:49:04.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="How-to-Resolve-SSH-Key-Issues-with-Multiple-Git-Services-🗝️"><a href="#How-to-Resolve-SSH-Key-Issues-with-Multiple-Git-Services-🗝️" class="headerlink" title="How to Resolve SSH Key Issues with Multiple Git Services 🗝️"></a>How to Resolve SSH Key Issues with Multiple Git Services 🗝️</h1><p>When using Git with different Git services such as GitHub and GitLab, you may encounter SSH key issues. This article will guide you on how to set up and configure SSH keys so that you can work smoothly with multiple services simultaneously.</p><h2 id="1-Generate-SSH-Keys-🔑"><a href="#1-Generate-SSH-Keys-🔑" class="headerlink" title="1. Generate SSH Keys 🔑"></a>1. Generate SSH Keys 🔑</h2><p>First, generate a separate SSH key for each Git service.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></tbody></table></figure><p>When generating the keys, save each key with a different filename, for example, <code>id_rsa_github</code> and <code>id_rsa_gitlab</code>.</p><h2 id="2-Add-SSH-Keys-to-Git-Services-🌐"><a href="#2-Add-SSH-Keys-to-Git-Services-🌐" class="headerlink" title="2. Add SSH Keys to Git Services 🌐"></a>2. Add SSH Keys to Git Services 🌐</h2><p>Log in to your GitHub and GitLab accounts, then add the generated public keys (<code>.pub</code> files) to the SSH key sections of each respective account.</p><h2 id="3-Configure-SSH-⚙️"><a href="#3-Configure-SSH-⚙️" class="headerlink" title="3. Configure SSH ⚙️"></a>3. Configure SSH ⚙️</h2><p>Create or edit the <code>~/.ssh/config</code> file to configure different SSH keys for each service.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GitHub</span></span><br><span class="line">Host github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  User git</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line"></span><br><span class="line"><span class="comment"># GitLab</span></span><br><span class="line">Host gitlab.com</span><br><span class="line">  HostName gitlab.com</span><br><span class="line">  User git</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_gitlab</span><br></pre></td></tr></tbody></table></figure><p>If your company uses a custom GitLab instance, add a separate configuration block for it.</p><h2 id="4-Test-SSH-Connections-🧪"><a href="#4-Test-SSH-Connections-🧪" class="headerlink" title="4. Test SSH Connections 🧪"></a>4. Test SSH Connections 🧪</h2><p>Test if you can successfully connect to each service via SSH.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">ssh -T git@gitlab.com</span><br></pre></td></tr></tbody></table></figure><h2 id="5-Handling-Common-Errors-❗"><a href="#5-Handling-Common-Errors-❗" class="headerlink" title="5. Handling Common Errors ❗"></a>5. Handling Common Errors ❗</h2><p>If you encounter errors such as “Permission denied (publickey)”, check the following:</p><ul><li>Ensure SSH keys are correctly added to the respective Git services.</li><li>Verify if the <code>~/.ssh/config</code> file is configured correctly.</li><li>Use the <code>ssh-add</code> command to ensure SSH keys are loaded into the SSH Agent.</li></ul><h2 id="6-Common-Issues-and-Solutions-💡"><a href="#6-Common-Issues-and-Solutions-💡" class="headerlink" title="6. Common Issues and Solutions 💡"></a>6. Common Issues and Solutions 💡</h2><ul><li><strong>Multiple GitLab Instances</strong>: If you use a custom GitLab instance along with GitLab.com, ensure they are separately configured in the SSH <code>config</code> file.</li><li><strong>Network Issues</strong>: Check if any network settings (like proxies, VPNs) might affect SSH connections.</li></ul><hr><p>By following the above steps, you should be able to resolve most SSH key-related issues, especially when dealing with multiple Git services. If you have further questions or specific scenarios, feel free to ask in the comments. 🚀✨</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;How-to-Resolve-SSH-Key-Issues-with-Multiple-Git-Services-🗝️&quot;&gt;&lt;a href=&quot;#How-to-Resolve-SSH-Key-Issues-with-Multiple-Git-Services-🗝️</summary>
      
    
    
    
    <category term="Debugging Diaries 🛠️" scheme="https://chenhuiyu.github.io/categories/Debugging-Diaries-%F0%9F%9B%A0%EF%B8%8F/"/>
    
    
    <category term="IssueFix 🔧" scheme="https://chenhuiyu.github.io/tags/IssueFix-%F0%9F%94%A7/"/>
    
  </entry>
  
  <entry>
    <title>如何解决多个 Git 服务的 SSH 密钥问题</title>
    <link href="https://chenhuiyu.github.io/2024/02/19/Debugging%20Diaries/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%9A%E4%B8%AA%20Git%20%E6%9C%8D%E5%8A%A1%E7%9A%84%20SSH%20%E5%AF%86%E9%92%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://chenhuiyu.github.io/2024/02/19/Debugging%20Diaries/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%9A%E4%B8%AA%20Git%20%E6%9C%8D%E5%8A%A1%E7%9A%84%20SSH%20%E5%AF%86%E9%92%A5%E9%97%AE%E9%A2%98/</id>
    <published>2024-02-19T07:47:55.000Z</published>
    <updated>2024-02-19T07:48:44.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何解决多个-Git-服务的-SSH-密钥问题-🗝️"><a href="#如何解决多个-Git-服务的-SSH-密钥问题-🗝️" class="headerlink" title="如何解决多个 Git 服务的 SSH 密钥问题 🗝️"></a>如何解决多个 Git 服务的 SSH 密钥问题 🗝️</h1><p>在使用 Git 和不同的 Git 服务（如 GitHub 和 GitLab）时，可能会遇到 SSH 密钥的问题。本文将指导你如何设置和配置 SSH 密钥，以便可以同时与多个服务顺利工作。</p><h2 id="1-生成-SSH-密钥-🔑"><a href="#1-生成-SSH-密钥-🔑" class="headerlink" title="1. 生成 SSH 密钥 🔑"></a>1. 生成 SSH 密钥 🔑</h2><p>首先，为每个 Git 服务生成一个独立的 SSH 密钥。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></tbody></table></figure><p>在生成密钥时，将每个密钥保存为不同的文件名，例如 <code>id_rsa_github</code> 和 <code>id_rsa_gitlab</code>。</p><h2 id="2-将-SSH-密钥添加到-Git-服务-🌐"><a href="#2-将-SSH-密钥添加到-Git-服务-🌐" class="headerlink" title="2. 将 SSH 密钥添加到 Git 服务 🌐"></a>2. 将 SSH 密钥添加到 Git 服务 🌐</h2><p>登录到你的 GitHub 和 GitLab 账户，然后将生成的公钥（<code>.pub</code> 文件）添加到各自账户的 SSH 密钥部分。</p><h2 id="3-配置-SSH-⚙️"><a href="#3-配置-SSH-⚙️" class="headerlink" title="3. 配置 SSH ⚙️"></a>3. 配置 SSH ⚙️</h2><p>创建或编辑 <code>~/.ssh/config</code> 文件，为每个服务配置不同的 SSH 密钥。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GitHub</span></span><br><span class="line">Host github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  User git</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line"></span><br><span class="line"><span class="comment"># GitLab</span></span><br><span class="line">Host gitlab.com</span><br><span class="line">  HostName gitlab.com</span><br><span class="line">  User git</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_gitlab</span><br></pre></td></tr></tbody></table></figure><p>如果你的公司使用自定义的 GitLab 实例，请为其添加一个单独的配置块。</p><h2 id="4-测试-SSH-连接-🧪"><a href="#4-测试-SSH-连接-🧪" class="headerlink" title="4. 测试 SSH 连接 🧪"></a>4. 测试 SSH 连接 🧪</h2><p>测试是否能成功通过 SSH 连接到每个服务。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">ssh -T git@gitlab.com</span><br></pre></td></tr></tbody></table></figure><h2 id="5-处理常见错误-❗"><a href="#5-处理常见错误-❗" class="headerlink" title="5. 处理常见错误 ❗"></a>5. 处理常见错误 ❗</h2><p>如果遇到错误，如 “Permission denied (publickey)”，请检查以下几点：</p><ul><li>确认 SSH 密钥是否已正确添加到相应的 Git 服务。</li><li>检查 <code>~/.ssh/config</code> 文件是否正确配置。</li><li>使用 <code>ssh-add</code> 命令确保 SSH 密钥已加载到 SSH Agent。</li></ul><h2 id="6-常见问题和解决方案-💡"><a href="#6-常见问题和解决方案-💡" class="headerlink" title="6. 常见问题和解决方案 💡"></a>6. 常见问题和解决方案 💡</h2><ul><li><strong>多个 GitLab 实例</strong>：如果你使用了公司的自定义 GitLab 实例和 GitLab.com，请确保 SSH <code>config</code> 文件中它们的配置是分开的。</li><li><strong>网络问题</strong>：检查是否有网络设置（如代理、VPN）可能影响 SSH 连接。</li></ul><hr><p>通过遵循以上步骤，你应该能够解决大部分与 SSH 密钥相关的问题，特别是在处理多个 Git 服务时。如果有进一步的问题或者特殊情况，欢迎在评论中提出。 🚀✨</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何解决多个-Git-服务的-SSH-密钥问题-🗝️&quot;&gt;&lt;a href=&quot;#如何解决多个-Git-服务的-SSH-密钥问题-🗝️&quot; class=&quot;headerlink&quot; title=&quot;如何解决多个 Git 服务的 SSH 密钥问题 🗝️&quot;&gt;&lt;/a&gt;如何解决多</summary>
      
    
    
    
    <category term="Debugging Diaries 🛠️" scheme="https://chenhuiyu.github.io/categories/Debugging-Diaries-%F0%9F%9B%A0%EF%B8%8F/"/>
    
    
    <category term="IssueFix 🔧" scheme="https://chenhuiyu.github.io/tags/IssueFix-%F0%9F%94%A7/"/>
    
  </entry>
  
  <entry>
    <title>理解大型语言模型中Fine-tuning和Further Pretraining的区别</title>
    <link href="https://chenhuiyu.github.io/2024/02/19/NLP%20Insights/%E7%90%86%E8%A7%A3%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E4%B8%ADFine-tuning%E5%92%8CFurther%20Pretraining%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://chenhuiyu.github.io/2024/02/19/NLP%20Insights/%E7%90%86%E8%A7%A3%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E4%B8%ADFine-tuning%E5%92%8CFurther%20Pretraining%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-02-19T07:10:29.000Z</published>
    <updated>2024-02-19T08:56:59.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解大型语言模型中-Fine-tuning-和-Further-Pretraining-的区别"><a href="#理解大型语言模型中-Fine-tuning-和-Further-Pretraining-的区别" class="headerlink" title="理解大型语言模型中 Fine-tuning 和 Further Pretraining 的区别"></a>理解大型语言模型中 Fine-tuning 和 Further Pretraining 的区别</h1><p>在自然语言处理（NLP）领域，大型语言模型，如 GPT 和 BERT 的出现，彻底改变了我们处理文本分类、情感分析和问答等任务的方式。在这些模型的应用中，Fine-tuning（微调）和 Further Pretraining（进一步预训练）是两种关键技术。虽然它们看起来相似，但实际上服务于 NLP 流程中的不同需求和场景。</p><h2 id="什么是-Fine-tuning？"><a href="#什么是-Fine-tuning？" class="headerlink" title="什么是 Fine-tuning？"></a>什么是 Fine-tuning？</h2><p>Fine-tuning 是指在特定任务的数据集上进一步训练（或“微调”）一个预训练好的模型的过程。这种方法在数据集相对较小但标注良好的情况下特别有效。</p><h3 id="示例场景：情感分析"><a href="#示例场景：情感分析" class="headerlink" title="示例场景：情感分析"></a>示例场景：情感分析</h3><p>假设你有一组电影评论数据，每条评论都标记了正面或负面情感。你想创建一个模型来预测评论的情感。</p><h4 id="Python-代码示例（使用-PyTorch-和-HuggingFace-的-Transformers）"><a href="#Python-代码示例（使用-PyTorch-和-HuggingFace-的-Transformers）" class="headerlink" title="Python 代码示例（使用 PyTorch 和 HuggingFace 的 Transformers）"></a>Python 代码示例（使用 PyTorch 和 HuggingFace 的 Transformers）</h4><p>This notebook demonstrates the fine-tuning of a BERT model on the IMDB dataset for sentiment analysis. For detailed code implementation, please refer to the following link:<a href="https://colab.research.google.com/drive/15naxP8pNMoCCBMgMSOv4ETDRGL46YR38?usp=sharing">link</a>.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> (</span><br><span class="line">    BertTokenizer,</span><br><span class="line">    BertForSequenceClassification,</span><br><span class="line">    Trainer,</span><br><span class="line">    TrainingArguments,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset, DatasetDict</span><br><span class="line"></span><br><span class="line"><span class="string">"""## 1.加载和准备IMDB数据集样本</span></span><br><span class="line"><span class="string">选取一部分数据用于Fine-tuning。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载IMDB数据集</span></span><br><span class="line">dataset = load_dataset(<span class="string">'imdb'</span>, split=<span class="string">'train'</span>)</span><br><span class="line">small_dataset = dataset.shuffle(seed=<span class="number">42</span>).select(<span class="built_in">range</span>(<span class="number">10000</span>))  <span class="comment"># 选取前10000个样本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化tokenizer</span></span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(<span class="string">"bert-base-uncased"</span>)</span><br><span class="line"></span><br><span class="line">device = <span class="string">"cuda"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">examples</span>):</span><br><span class="line">    <span class="keyword">return</span> tokenizer(examples[<span class="string">"text"</span>], padding=<span class="string">"max_length"</span>, truncation=<span class="literal">True</span>, max_length=<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">encoded_small_dataset = small_dataset.<span class="built_in">map</span>(encode, batched=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertModel</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_attention</span>(<span class="params">sentence, model, tokenizer</span>):</span><br><span class="line">    model.to(device)</span><br><span class="line">    <span class="comment"># 将模型设置为评估模式</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将输入文本转换为模型可以理解的形式</span></span><br><span class="line">    inputs = tokenizer(sentence, return_tensors=<span class="string">"pt"</span>).to(device) <span class="comment"># 确保输入也在相同设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用模型获取注意力权重</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        outputs = model(**inputs)</span><br><span class="line">    attentions = outputs.attentions</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择要可视化的层和头</span></span><br><span class="line">    layer = <span class="number">5</span></span><br><span class="line">    head = <span class="number">1</span></span><br><span class="line">    attention = attentions[layer][<span class="number">0</span>, head].cpu().numpy() <span class="comment"># 将注意力权重移回CPU进行可视化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置可视化的tokens</span></span><br><span class="line">    tokens = tokenizer.convert_ids_to_tokens(inputs[<span class="string">"input_ids"</span>][<span class="number">0</span>].cpu()) <span class="comment"># 同样确保tokens在CPU上</span></span><br><span class="line">    <span class="comment"># 绘制注意力矩阵</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">    plt.matshow(attention, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    plt.xticks(<span class="built_in">range</span>(<span class="built_in">len</span>(tokens)), tokens, rotation=<span class="number">90</span>)</span><br><span class="line">    plt.yticks(<span class="built_in">range</span>(<span class="built_in">len</span>(tokens)), tokens)</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="string">"""## 2. 可视化一个样本句子的注意力权重（未经Fine-tuning）</span></span><br><span class="line"><span class="string">选择数据集中的一个句子并展示其原始BERT模型的注意力权重。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用未经Fine-tuning的模型</span></span><br><span class="line">model = BertModel.from_pretrained(<span class="string">"bert-base-uncased"</span>, output_attentions=<span class="literal">True</span>)</span><br><span class="line">sample_sentence = <span class="string">"I love this movie, it's fantastic!"</span></span><br><span class="line">visualize_attention(sample_sentence, model, tokenizer)</span><br><span class="line"></span><br><span class="line"><span class="string">"""## 3. Fine-tuning BERT模型</span></span><br><span class="line"><span class="string">在选取的IMDB样本上进行Fine-tuning。</span></span><br><span class="line"><span class="string">### 3.1 准备数据加载器</span></span><br><span class="line"><span class="string">为了训练模型，我们需要创建PyTorch的DataLoader。这将使我们能够在训练过程中有效地加载数据。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 3.2 设置Fine-tuning环境</span></span><br><span class="line"><span class="string">初始化模型、优化器以及损失函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 3.3 Fine-tuning模型</span></span><br><span class="line"><span class="string">执行Fine-tuning的训练循环。执行以上代码将在IMDB数据集的小样本上对BERT模型进行Fine-tuning。这可能需要一些时间，具体取决于您的硬件配置。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据集转换为PyTorch Tensor</span></span><br><span class="line">encoded_small_dataset.set_format(<span class="string">'torch'</span>, columns=[<span class="string">'input_ids'</span>, <span class="string">'attention_mask'</span>, <span class="string">'label'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据加载器</span></span><br><span class="line">train_loader = DataLoader(encoded_small_dataset, batch_size=<span class="number">8</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertConfig, BertForSequenceClassification</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载配置并设置输出注意力权重</span></span><br><span class="line">config = BertConfig.from_pretrained(<span class="string">"bert-base-uncased"</span>, output_attentions=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化用于序列分类的BERT模型</span></span><br><span class="line"><span class="comment"># 使用更新后的配置加载模型</span></span><br><span class="line">model = BertForSequenceClassification.from_pretrained(<span class="string">"bert-base-uncased"</span>, config=config)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置优化器</span></span><br><span class="line">optimizer = optim.AdamW(model.parameters(), lr=<span class="number">5e-5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用交叉熵损失函数</span></span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置训练的轮次</span></span><br><span class="line">epochs = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    model.train()</span><br><span class="line">    total_loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> train_loader:</span><br><span class="line">        <span class="comment"># 将数据移至GPU</span></span><br><span class="line">        input_ids = batch[<span class="string">'input_ids'</span>].to(device)</span><br><span class="line">        attention_mask = batch[<span class="string">'attention_mask'</span>].to(device)</span><br><span class="line">        labels = batch[<span class="string">'label'</span>].to(device)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 模型前向传播</span></span><br><span class="line">        outputs = model(input_ids, attention_mask=attention_mask)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算损失</span></span><br><span class="line">        loss = criterion(outputs.logits, labels)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反向传播和优化</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        total_loss += loss.item()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Epoch: <span class="subst">{epoch+<span class="number">1</span>}</span>, Loss: <span class="subst">{total_loss/<span class="built_in">len</span>(train_loader)}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"""### 4. 可视化同一句子的注意力权重（经过Fine-tuning）</span></span><br><span class="line"><span class="string">使用Fine-tuning后的模型再次可视化同一句子的注意力权重。您可以重用之前提供的visualize_attention函数：</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">visualize_attention(sample_sentence, model, tokenizer)</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，BERT 模型在电影评论数据集上进行了 fine-tuning，用于情感分析。</p><h2 id="什么是-Further-Pretraining？"><a href="#什么是-Further-Pretraining？" class="headerlink" title="什么是 Further Pretraining？"></a>什么是 Further Pretraining？</h2><p>Further Pretraining（也称为 Domain-adaptive Pretraining，领域适应性预训练）是在一个新的数据集上继续训练一个预训练模型的过程，这个新的数据集与特定的领域更相关，但不一定为特定任务标注。</p><h3 id="示例场景：法律文档分析"><a href="#示例场景：法律文档分析" class="headerlink" title="示例场景：法律文档分析"></a>示例场景：法律文档分析</h3><p>假设你正在处理法律文档，并希望利用一个在通用文本上训练的语言模型。</p><h4 id="Further-Pretraining-的代码示例"><a href="#Further-Pretraining-的代码示例" class="headerlink" title="Further Pretraining 的代码示例"></a>Further Pretraining 的代码示例</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertModel, BertTokenizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载预训练的BERT模型和分词器</span></span><br><span class="line">model = BertModel.from_pretrained(<span class="string">'bert-base-uncased'</span>)</span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(<span class="string">'bert-base-uncased'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备法律文档数据集</span></span><br><span class="line"><span class="comment"># 假设'legal_documents'是法律文档的文本列表</span></span><br><span class="line">encoded_input = tokenizer(legal_documents, padding=<span class="literal">True</span>, truncation=<span class="literal">True</span>, max_length=<span class="number">512</span>, return_tensors=<span class="string">'pt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续预训练模型</span></span><br><span class="line"><span class="comment"># 这一步通常包括掩码语言建模或其他预训练目标</span></span><br><span class="line"><span class="comment"># 这里提供一个概念性示例</span></span><br><span class="line">model.train()</span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> encoded_input:</span><br><span class="line">    outputs = model(**batch)</span><br><span class="line">    <span class="comment"># ... 执行进一步训练步骤</span></span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，BERT 模型在法律文档数据集上进行了进一步的预训练，使其在进行特定法律 NLP 任务的 fine-tuning 之前，更擅长理解法律术语和概念。</p><h2 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h2><ul><li><strong>目的</strong>：Fine-tuning 针对具有标签数据的特定任务进行模型调整，而 Further Pretraining 则是使模型更好地适应特定领域或语言风格。</li><li><strong>数据集</strong>：Fine-tuning 使用特定任务的标注数据集。Further Pretraining 使用更大的、特定领域的数据集，这些数据集可能不是为特定任务标注的。</li><li><strong>训练目标</strong>：Fine-tuning 涉及调整模型进行特定预测，而 Further Pretraining 侧重于在新领域中的通用语言理解</li></ul><p>。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Fine-tuning 和 Further Pretraining 都是 NLP 领域的强大技术。通过理解它们的区别和应用，我们可以更好地利用大型语言模型来解决各种领域中的多样化和复杂任务。无论你是在构建社交媒体帖子的情感分析模型，还是调整模型以理解法律文档，这些技术都为 NLP 领域的不断发展提供了稳健的解决方案。</p><hr><p><strong>注意</strong>：提供的代码示例是概念性的，需要适当的环境设置，包括必要的库和数据集，才能执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;理解大型语言模型中-Fine-tuning-和-Further-Pretraining-的区别&quot;&gt;&lt;a href=&quot;#理解大型语言模型中-Fine-tuning-和-Further-Pretraining-的区别&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="NLP Insights" scheme="https://chenhuiyu.github.io/categories/NLP-Insights/"/>
    
    
    <category term="LLM" scheme="https://chenhuiyu.github.io/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>Understanding the Differences Between Fine-tuning and Further Pretraining in Large Language Models</title>
    <link href="https://chenhuiyu.github.io/2024/02/19/NLP%20Insights/Understanding%20the%20Differences%20Between%20Fine-tuning%20and%20Further%20Pretraining%20in%20Large%20Language%20Models/"/>
    <id>https://chenhuiyu.github.io/2024/02/19/NLP%20Insights/Understanding%20the%20Differences%20Between%20Fine-tuning%20and%20Further%20Pretraining%20in%20Large%20Language%20Models/</id>
    <published>2024-02-19T07:06:29.000Z</published>
    <updated>2024-02-19T08:53:58.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Understanding-the-Differences-Between-Fine-tuning-and-Further-Pretraining-in-Large-Language-Models"><a href="#Understanding-the-Differences-Between-Fine-tuning-and-Further-Pretraining-in-Large-Language-Models" class="headerlink" title="Understanding the Differences Between Fine-tuning and Further Pretraining in Large Language Models"></a>Understanding the Differences Between Fine-tuning and Further Pretraining in Large Language Models</h1><p>In the world of Natural Language Processing (NLP), the advent of large language models like GPT and BERT has revolutionized how we approach tasks such as text classification, sentiment analysis, and question-answering. Two pivotal techniques in leveraging these models are Fine-tuning and Further Pretraining. While they may seem similar at a glance, they cater to different needs and scenarios in the NLP pipeline.</p><h2 id="What-is-Fine-tuning"><a href="#What-is-Fine-tuning" class="headerlink" title="What is Fine-tuning?"></a>What is Fine-tuning?</h2><p>Fine-tuning is a process where a pretrained model is further trained (or ‘fine-tuned’) on a specific task with a dataset corresponding to that task. This approach is particularly effective when the dataset is relatively small but well-labeled.</p><h3 id="Example-Scenario-Sentiment-Analysis"><a href="#Example-Scenario-Sentiment-Analysis" class="headerlink" title="Example Scenario: Sentiment Analysis"></a>Example Scenario: Sentiment Analysis</h3><p>Imagine you have a dataset of movie reviews, each labeled as positive or negative. You want to create a model that can predict the sentiment of a review.</p><h4 id="Code-Snippet-in-Python-using-PyTorch-and-HuggingFace’s-Transformers"><a href="#Code-Snippet-in-Python-using-PyTorch-and-HuggingFace’s-Transformers" class="headerlink" title="Code Snippet in Python (using PyTorch and HuggingFace’s Transformers)"></a>Code Snippet in Python (using PyTorch and HuggingFace’s Transformers)</h4><p>This notebook demonstrates the fine-tuning of a BERT model on the IMDB dataset for sentiment analysis. For detailed code implementation, please refer to the following link:<a href="https://colab.research.google.com/drive/15naxP8pNMoCCBMgMSOv4ETDRGL46YR38?usp=sharing">link</a>.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~/.ssh</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> (</span><br><span class="line">    BertTokenizer,</span><br><span class="line">    BertForSequenceClassification,</span><br><span class="line">    Trainer,</span><br><span class="line">    TrainingArguments,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset, DatasetDict</span><br><span class="line"></span><br><span class="line"><span class="string">"""## 1. Load and Prepare IMDB Dataset Samples</span></span><br><span class="line"><span class="string">Select a portion of the data for Fine-tuning.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load IMDB dataset</span></span><br><span class="line">dataset = load_dataset(<span class="string">'imdb'</span>, split=<span class="string">'train'</span>)</span><br><span class="line">small_dataset = dataset.shuffle(seed=<span class="number">42</span>).select(<span class="built_in">range</span>(<span class="number">10000</span>))  <span class="comment"># Selecting the first 10,000 samples</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize tokenizer</span></span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(<span class="string">"bert-base-uncased"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Encode the dataset</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">examples</span>):</span><br><span class="line">    <span class="keyword">return</span> tokenizer(examples[<span class="string">"text"</span>], padding=<span class="string">"max_length"</span>, truncation=<span class="literal">True</span>, max_length=<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">encoded_small_dataset = small_dataset.<span class="built_in">map</span>(encode, batched=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertModel</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_attention</span>(<span class="params">sentence, model, tokenizer</span>):</span><br><span class="line">    <span class="comment"># Set the model to evaluation mode</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Convert the input text into a format understandable by the model</span></span><br><span class="line">    inputs = tokenizer(sentence, return_tensors=<span class="string">"pt"</span>).to(device) <span class="comment"># Making sure inputs are on the same device</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get attention weights using the model</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        outputs = model(**inputs)</span><br><span class="line">    attentions = outputs.attentions</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Choose the layer and head to visualize</span></span><br><span class="line">    layer = <span class="number">5</span></span><br><span class="line">    head = <span class="number">1</span></span><br><span class="line">    attention = attentions[layer][<span class="number">0</span>, head].cpu().numpy() <span class="comment"># Move attention weights back to CPU for visualization</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set tokens for visualization</span></span><br><span class="line">    tokens = tokenizer.convert_ids_to_tokens(inputs[<span class="string">"input_ids"</span>][<span class="number">0</span>].cpu()) <span class="comment"># Also make sure tokens are on CPU</span></span><br><span class="line">    <span class="comment"># Plot attention matrix</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">    plt.matshow(attention, cmap=<span class="string">'viridis'</span>)</span><br><span class="line">    plt.xticks(<span class="built_in">range</span>(<span class="built_in">len</span>(tokens)), tokens, rotation=<span class="number">90</span>)</span><br><span class="line">    plt.yticks(<span class="built_in">range</span>(<span class="built_in">len</span>(tokens)), tokens)</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="string">"""## 2. Visualize Attention Weights of a Sample Sentence (Before Fine-tuning)</span></span><br><span class="line"><span class="string">Select a sentence from the dataset and visualize the attention weights of the original BERT model.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use the model without Fine-tuning</span></span><br><span class="line">model = BertModel.from_pretrained(<span class="string">"bert-base-uncased"</span>, output_attentions=<span class="literal">True</span>)</span><br><span class="line">sample_sentence = <span class="string">"I love this movie, it's fantastic!"</span></span><br><span class="line">visualize_attention(sample_sentence, model, tokenizer)</span><br><span class="line"></span><br><span class="line"><span class="string">"""## 3. Fine-tuning the BERT Model</span></span><br><span class="line"><span class="string">Perform Fine-tuning on the selected IMDB samples.</span></span><br><span class="line"><span class="string">### 3.1 Prepare Data Loaders</span></span><br><span class="line"><span class="string">To train the model, we need to create PyTorch's DataLoader. This will allow us to efficiently load data during training.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 3.2 Set up Fine-tuning Environment</span></span><br><span class="line"><span class="string">Initialize the model, optimizer, and loss function.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 3.3 Fine-tuning the Model</span></span><br><span class="line"><span class="string">Execute the training loop for Fine-tuning. Running the above code will Fine-tune the BERT model on a small sample of the IMDB dataset. This may take some time depending on your hardware configuration.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert the dataset to PyTorch Tensor</span></span><br><span class="line">encoded_small_dataset.set_format(<span class="string">'torch'</span>, columns=[<span class="string">'input_ids'</span>, <span class="string">'attention_mask'</span>, <span class="string">'label'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create data loader</span></span><br><span class="line">train_loader = DataLoader(encoded_small_dataset, batch_size=<span class="number">8</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertConfig, BertForSequenceClassification</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the configuration and set output attention weights</span></span><br><span class="line">config = BertConfig.from_pretrained(<span class="string">"bert-base-uncased"</span>, output_attentions=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the BERT model for sequence classification</span></span><br><span class="line"><span class="comment"># Load the model with updated configuration</span></span><br><span class="line">model = BertForSequenceClassification.from_pretrained(<span class="string">"bert-base-uncased"</span>, config=config)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up the optimizer</span></span><br><span class="line">optimizer = optim.AdamW(model.parameters(), lr=<span class="number">5e-5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use the cross-entropy loss function</span></span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">device = <span class="string">"cuda"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span></span><br><span class="line">model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the number of epochs for training</span></span><br><span class="line">epochs = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    model.train()</span><br><span class="line">    total_loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> train_loader:</span><br><span class="line">        <span class="comment"># Move the data to GPU</span></span><br><span class="line">        input_ids = batch[<span class="string">'input_ids'</span>].to(device)</span><br><span class="line">        attention_mask = batch[<span class="string">'attention_mask'</span>].to(device)</span><br><span class="line">        labels = batch[<span class="string">'label'</span>].to(device)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Model forward pass</span></span><br><span class="line">        outputs = model(input_ids, attention_mask=attention_mask)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Compute the loss</span></span><br><span class="line">        loss = criterion(outputs.logits, labels)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Backpropagation and optimization</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        total_loss += loss.item()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Epoch: <span class="subst">{epoch+<span class="number">1</span>}</span>, Loss: <span class="subst">{total_loss/<span class="built_in">len</span>(train_loader)}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"""### 4. Visualize Attention Weights of the Same Sentence (After Fine-tuning)</span></span><br><span class="line"><span class="string">Visualize the attention weights of the same sentence using the model after Fine-tuning. You can reuse the visualize_attention function provided earlier:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">visualize_attention(sample_sentence, model, tokenizer)</span><br></pre></td></tr></tbody></table></figure><p>In this example, the BERT model is fine-tuned on the movie reviews dataset for sentiment analysis.</p><h2 id="What-is-Further-Pretraining"><a href="#What-is-Further-Pretraining" class="headerlink" title="What is Further Pretraining?"></a>What is Further Pretraining?</h2><p>Further Pretraining, also known as Domain-adaptive Pretraining, is where a pretrained model is further trained on a new dataset that is more closely related to the specific domain of interest but not necessarily labeled for a specific task.</p><h3 id="Example-Scenario-Legal-Document-Analysis"><a href="#Example-Scenario-Legal-Document-Analysis" class="headerlink" title="Example Scenario: Legal Document Analysis"></a>Example Scenario: Legal Document Analysis</h3><p>Suppose you’re working on legal documents and wish to leverage a language model trained on general texts.</p><h4 id="Code-Snippet-for-Further-Pretraining"><a href="#Code-Snippet-for-Further-Pretraining" class="headerlink" title="Code Snippet for Further Pretraining"></a>Code Snippet for Further Pretraining</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertModel, BertTokenizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load a pre-trained BERT model and tokenizer</span></span><br><span class="line">model = BertModel.from_pretrained(<span class="string">'bert-base-uncased'</span>)</span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(<span class="string">'bert-base-uncased'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare the legal documents dataset</span></span><br><span class="line"><span class="comment"># Assume 'legal_documents' is a list of text from legal documents</span></span><br><span class="line">encoded_input = tokenizer(legal_documents, padding=<span class="literal">True</span>, truncation=<span class="literal">True</span>, max_length=<span class="number">512</span>, return_tensors=<span class="string">'pt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Further pretrain the model</span></span><br><span class="line"><span class="comment"># This step typically involves masked language modeling or other pretraining objectives</span></span><br><span class="line"><span class="comment"># Here we provide a conceptual example</span></span><br><span class="line">model.train()</span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> encoded_input:</span><br><span class="line">    outputs = model(**batch)</span><br><span class="line">    <span class="comment"># ... Perform further training steps</span></span><br></pre></td></tr></tbody></table></figure><p>In this case, the BERT model is further pretrained on a legal document dataset, making it more adept at understanding legal jargon and concepts before being fine-tuned on a specific legal NLP task.</p><h2 id="Key-Differences"><a href="#Key-Differences" class="headerlink" title="Key Differences"></a>Key Differences</h2><ul><li><strong>Purpose</strong>: Fine-tuning is tailored for a specific task with labeled data, while Further Pretraining is about adapting the model to a specific domain or style of language.</li><li><strong>Dataset</strong>: Fine-tuning uses task-specific, labeled datasets. Further Pretraining uses larger, domain-specific datasets, which may not be labeled for a specific task.</li><li><strong>Training Objective</strong>: Fine-tuning involves adjusting the model to make specific predictions, while Further Pretraining focuses on general language understanding in a new domain.</li></ul><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Both Fine-tuning and Further Pretraining are powerful techniques in NLP. By understanding their differences and applications, we can better leverage large language models to solve diverse and complex tasks in various domains. Whether you’re building a sentiment analysis model for social media posts or adapting a model to understand legal documents, these techniques offer robust solutions in the ever-evolving field of NLP.</p><hr><p><strong>Note</strong>: The code examples provided are conceptual and require a suitable environment setup, including necessary libraries and datasets, for execution.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Understanding-the-Differences-Between-Fine-tuning-and-Further-Pretraining-in-Large-Language-Models&quot;&gt;&lt;a href=&quot;#Understanding-the-Diff</summary>
      
    
    
    
    <category term="NLP Insights" scheme="https://chenhuiyu.github.io/categories/NLP-Insights/"/>
    
    
    <category term="LLM" scheme="https://chenhuiyu.github.io/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>🤖 Create a Telegram Bot with Python and OpenAI in 10 Minutes! 🚀</title>
    <link href="https://chenhuiyu.github.io/2023/09/24/NLP%20Insights/Create%20a%20Telegram%20Bot%20with%20Python%20and%20OpenAI%20in%2010%20Minutes/"/>
    <id>https://chenhuiyu.github.io/2023/09/24/NLP%20Insights/Create%20a%20Telegram%20Bot%20with%20Python%20and%20OpenAI%20in%2010%20Minutes/</id>
    <published>2023-09-23T19:13:03.000Z</published>
    <updated>2023-09-23T19:13:36.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🤖-Create-a-Telegram-Bot-with-Python-and-OpenAI-in-10-Minutes-🚀"><a href="#🤖-Create-a-Telegram-Bot-with-Python-and-OpenAI-in-10-Minutes-🚀" class="headerlink" title="🤖 Create a Telegram Bot with Python and OpenAI in 10 Minutes! 🚀"></a>🤖 Create a Telegram Bot with Python and OpenAI in 10 Minutes! 🚀</h1><p>In this fun tutorial, we’ll show you how to create a Telegram bot that can chat with users and generate witty responses. We’ll explain each step in detail, making it easy for you to get started!</p><h2 id="Step-1-Create-a-Telegram-Bot-🤖"><a href="#Step-1-Create-a-Telegram-Bot-🤖" class="headerlink" title="Step 1: Create a Telegram Bot 🤖"></a>Step 1: Create a Telegram Bot 🤖</h2><p>First, let’s create your very own Telegram bot. Here’s how:</p><ol><li>Open the Telegram app and search for “BotFather.”</li><li>In the BotFather chat, use the <code>/newbot</code> command to create a new bot. You’ll need to give your bot a name, like “PunshineBot.”</li><li>BotFather will generate a unique API token for you. Be sure to save this token; we’ll use it in the code later.</li></ol><h2 id="Step-2-Import-Necessary-Libraries-📚"><a href="#Step-2-Import-Necessary-Libraries-📚" class="headerlink" title="Step 2: Import Necessary Libraries 📚"></a>Step 2: Import Necessary Libraries 📚</h2><p>We’ll first need to import some Python libraries to create the Telegram bot and perform natural language processing with OpenAI.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Final, Deque, <span class="type">Dict</span>, <span class="type">Union</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"><span class="keyword">from</span> telegram <span class="keyword">import</span> Update</span><br><span class="line"><span class="keyword">from</span> telegram.ext <span class="keyword">import</span> (</span><br><span class="line">    Application,</span><br><span class="line">    CommandHandler,</span><br><span class="line">    ContextTypes,</span><br><span class="line">    MessageHandler,</span><br><span class="line">    filters,</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>Make sure you have the Telegram Bot API and OpenAI Python library installed.</p><h2 id="Step-3-Set-API-Keys-and-Telegram-Token-🔑"><a href="#Step-3-Set-API-Keys-and-Telegram-Token-🔑" class="headerlink" title="Step 3: Set API Keys and Telegram Token 🔑"></a>Step 3: Set API Keys and Telegram Token 🔑</h2><p>In this step, we need to set the OpenAI API key and Telegram bot token. Make sure you’ve signed up for OpenAI and obtained your API key. Then, replace the example API key and Telegram token in the following code with your own:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openai.api_key = <span class="string">"Your OpenAI API Key"</span></span><br><span class="line">TOKEN: Final = <span class="string">"Your Telegram Bot Token"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Step-4-Create-Start-and-Help-Commands-🚀"><a href="#Step-4-Create-Start-and-Help-Commands-🚀" class="headerlink" title="Step 4: Create Start and Help Commands 🚀"></a>Step 4: Create Start and Help Commands 🚀</h2><p>Next, we’ll create two command handling functions for the start and help commands. These commands allow users to interact with the bot.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">start_command</span>(<span class="params">update: Update, context: ContextTypes.DEFAULT_TYPE</span>):</span><br><span class="line">    <span class="keyword">await</span> update.message.reply_text(<span class="string">"Hello, world! 😄"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">help_command</span>(<span class="params">update: Update, context: ContextTypes.DEFAULT_TYPE</span>):</span><br><span class="line">    <span class="keyword">await</span> update.message.reply_text(<span class="string">"I'm PunShine Bot, and I can help you find the funniest puns! 😂"</span>)</span><br></pre></td></tr></tbody></table></figure><p>The <code>start_command</code> function handles the start command, responding with “Hello, world! 😄” when users send the <code>/start</code> command. The <code>help_command</code> function handles the help command, providing assistance when users send the <code>/help</code> command.</p><h2 id="Step-5-Handle-User-Messages-📨"><a href="#Step-5-Handle-User-Messages-📨" class="headerlink" title="Step 5: Handle User Messages 📨"></a>Step 5: Handle User Messages 📨</h2><p>In this step, we define the <code>handle_response</code> function to process user messages and create the <code>message_handler</code>. The function adds user messages to the conversation history and uses the OpenAI API to generate responses.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_response</span>(<span class="params">chat_id: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>], text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># Get the chat history</span></span><br><span class="line">    chat_history = get_chat_history(chat_id)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create a user message</span></span><br><span class="line">    user_message = {<span class="string">"role"</span>: <span class="string">"user"</span>, <span class="string">"content"</span>: text}</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Add the user message to the chat history</span></span><br><span class="line">    chat_history.append(user_message)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build a message list, including a system message and user messages</span></span><br><span class="line">    messages = [</span><br><span class="line">        {</span><br><span class="line">            <span class="string">"role"</span>: <span class="string">"system"</span>,</span><br><span class="line">            <span class="string">"content"</span>: <span class="string">"You are PunshineBot, reply in English, keep it casual, use emojis, and keep responses short. 😄🚀"</span>,</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">    messages.extend(chat_history)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Use the OpenAI API to generate the bot's response</span></span><br><span class="line">    response = openai.ChatCompletion.create(</span><br><span class="line">        model=<span class="string">"gpt-3.5-turbo"</span>,</span><br><span class="line">        messages=messages,</span><br><span class="line">        temperature=<span class="number">1</span>,</span><br><span class="line">        max_tokens=<span class="number">256</span>,</span><br><span class="line">        top_p=<span class="number">1</span>,</span><br><span class="line">        frequency_penalty=<span class="number">0</span>,</span><br><span class="line">        presence_penalty=<span class="number">0</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    bot_response = response[<span class="string">"choices"</span>][<span class="number">0</span>][<span class="string">"message"</span>][<span class="string">"content"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Add the bot's response to the conversation history</span></span><br><span class="line">    chat_history.append({<span class="string">"role"</span>: <span class="string">"assistant"</span>, <span class="string">"content"</span>: bot_response})</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bot_response</span><br></pre></td></tr></tbody></table></figure><p>The <code>handle_response</code> function adds user messages to the conversation history and generates the bot’s response using the OpenAI API. The <code>message_handler</code> function processes messages sent by users, checking their type (group message or private chat) and content, and then calls the <code>handle_response</code> function to generate the bot’s response.</p><h2 id="Step-6-Run-the-Telegram-Bot-🚀"><a href="#Step-6-Run-the-Telegram-Bot-🚀" class="headerlink" title="Step 6: Run the Telegram Bot 🚀"></a>Step 6: Run the Telegram Bot 🚀</h2><p>Finally, in the main function, we create a Telegram bot application, add command handlers and message handlers, and start the Telegram bot to receive and process messages.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = Application.builder().token(TOKEN).build()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add command handlers</span></span><br><span class="line">    app.add_handler(CommandHandler(<span class="string">"start"</span>, start_command))</span><br><span class="line">    app.add_handler(CommandHandler(<span class="string">"help"</span>, help_command))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add message handler</span></span><br><span class="line">    app.add_handler(MessageHandler(filters.TEXT, callback=message_handler))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Start the Telegram bot</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Bot started! 😎🤖"</span>)</span><br><span class="line">    app.run_polling(poll_interval=<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>app.run_polling(poll_interval=1)</code> starts the Telegram bot, polling for new messages every second. This keeps the bot running and triggers the respective handlers when it receives messages.</p><h2 id="Step-7-Host-Your-Telegram-Bot-Online-for-Free-24-x2F-7-🚀"><a href="#Step-7-Host-Your-Telegram-Bot-Online-for-Free-24-x2F-7-🚀" class="headerlink" title="Step 7: Host Your Telegram Bot Online for Free 24/7 🚀"></a>Step 7: Host Your Telegram Bot Online for Free 24/7 🚀</h2><p>In the previous tutorial, we showed you how to create a Telegram bot. However, to keep your bot online 24/7, you would need to leave your computer running, which can be inconvenient. In this blog post, we’ll show you how to host your bot for free on a cloud server so that it can run around the clock.</p><p>PythonAnywhere is a website that allows you to host Python code for free. It comes with some usage limitations, but it’s perfect for simple use cases. Here’s how to use PythonAnywhere to host your Telegram bot.</p><ol><li>Visit the <a href="https://www.pythonanywhere.com/">PythonAnywhere website</a> and create an account.</li></ol><h3 id="Step-7-1-Create-a-Python-Script"><a href="#Step-7-1-Create-a-Python-Script" class="headerlink" title="Step 7.1: Create a Python Script"></a>Step 7.1: Create a Python Script</h3><p>Once you’re logged into the PythonAnywhere dashboard, you’ll see an option called “Files.” Click on it and create a new file. Name it “telegram_bot.py.” In this file, paste the Telegram bot code you created earlier.</p><h3 id="Step-7-2-Install-Required-Packages"><a href="#Step-7-2-Install-Required-Packages" class="headerlink" title="Step 7.2: Install Required Packages"></a>Step 7.2: Install Required Packages</h3><p>Before running the Telegram bot, we need to install the necessary Python packages. PythonAnywhere provides a command-line interface where you can execute the following commands:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install python-telegram-bot</span><br><span class="line">pip install openai</span><br></pre></td></tr></tbody></table></figure><p>This will install the Telegram bot library, allowing your code to communicate with the Telegram servers.</p><h3 id="Step-7-3-Run-the-Bot"><a href="#Step-7-3-Run-the-Bot" class="headerlink" title="Step 7.3: Run the Bot"></a>Step 7.3: Run the Bot</h3><p>Now, go back to the PythonAnywhere dashboard and find your “telegram_bot.py” file under “Files.” Click the “Run” button, and your bot will start running. The bot will stay online even if you close your computer.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>You’ve now learned how to create a Python Telegram bot, integrate it with OpenAI to respond to user messages, and host it for free on a cloud server, ensuring it remains online 24/7. This way, you can interact with your bot without worrying about whether your computer is on. If you have other free hosting services or questions, feel free to share in the comments! Happy bot building! 🤖🚀😄</p><p>Additionally, if you want to learn more about hosting bots on Discord, you can watch this YouTube video: <a href="https://www.youtube.com/watch?v=2TI-tCVhe9k">How To Host Your Bot Online 24/7 For FREE With Python (Telegram, Discord, Etc)</a>. The video provides more detailed tutorials and examples.</p><p>If you have any questions or need further assistance, please don’t hesitate to leave a comment. Happy coding! 🚀🤖😄</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.youtube.com/watch?v=vZtm1wuA2yc">How To Create A Telegram Bot In Python For Beginners (2023 Tutorial)</a></li><li><a href="https://www.youtube.com/watch?v=2TI-tCVhe9k">How To Host Your Bot Online 24/7 For FREE With Python (Telegram, Discord, Etc)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🤖-Create-a-Telegram-Bot-with-Python-and-OpenAI-in-10-Minutes-🚀&quot;&gt;&lt;a href=&quot;#🤖-Create-a-Telegram-Bot-with-Python-and-OpenAI-in-10-Mi</summary>
      
    
    
    
    <category term="Code Chronicles" scheme="https://chenhuiyu.github.io/categories/Code-Chronicles/"/>
    
    
    <category term="Chatbot" scheme="https://chenhuiyu.github.io/tags/Chatbot/"/>
    
  </entry>
  
  <entry>
    <title>🤖 十分钟用 Python 和 OpenAI 创建 Telegram 机器人！ 🚀</title>
    <link href="https://chenhuiyu.github.io/2023/09/24/NLP%20Insights/%E5%8D%81%E5%88%86%E9%92%9F%E7%94%A8%20Python%20%E5%92%8C%20OpenAI%20%E5%88%9B%E5%BB%BA%20Telegram%20%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>https://chenhuiyu.github.io/2023/09/24/NLP%20Insights/%E5%8D%81%E5%88%86%E9%92%9F%E7%94%A8%20Python%20%E5%92%8C%20OpenAI%20%E5%88%9B%E5%BB%BA%20Telegram%20%E6%9C%BA%E5%99%A8%E4%BA%BA/</id>
    <published>2023-09-23T19:12:03.000Z</published>
    <updated>2023-09-23T19:13:00.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🤖-十分钟用-Python-和-OpenAI-创建-Telegram-机器人！-🚀"><a href="#🤖-十分钟用-Python-和-OpenAI-创建-Telegram-机器人！-🚀" class="headerlink" title="🤖 十分钟用 Python 和 OpenAI 创建 Telegram 机器人！ 🚀"></a>🤖 十分钟用 Python 和 OpenAI 创建 Telegram 机器人！ 🚀</h1><p>在这个有趣的教程中，我们将向您展示如何创建一个具有的 Telegram 机器人，该机器人能够与用户聊天并生成幽默回复。我们将详细解释每一步，让您轻松入门！</p><h2 id="步骤-1：创建-Telegram-机器人-🤖"><a href="#步骤-1：创建-Telegram-机器人-🤖" class="headerlink" title="步骤 1：创建 Telegram 机器人 🤖"></a>步骤 1：创建 Telegram 机器人 🤖</h2><p>首先，让我们来创建您自己的 Telegram 机器人。这是如何做的：</p><ol><li>打开 Telegram 应用并搜索 “BotFather”。</li><li>在 BotFather 聊天中，使用 <code>/newbot</code> 命令创建一个新机器人。您需要为机器人取个名字，比如 “PunshineBot”。</li><li>BotFather 会为您生成一个独一无二的 API 令牌（Token）。一定要妥善保存这个令牌，稍后我们会在代码中用到它。</li></ol><img src="/2023/09/24/NLP%20Insights/%E5%8D%81%E5%88%86%E9%92%9F%E7%94%A8%20Python%20%E5%92%8C%20OpenAI%20%E5%88%9B%E5%BB%BA%20Telegram%20%E6%9C%BA%E5%99%A8%E4%BA%BA/step1.jpg" class=""><h2 id="步骤-2：导入必要的库-📚"><a href="#步骤-2：导入必要的库-📚" class="headerlink" title="步骤 2：导入必要的库 📚"></a>步骤 2：导入必要的库 📚</h2><p>我们首先需要导入一些 Python 库，以便创建 Telegram 机器人并与 OpenAI 进行自然语言处理。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Final, Deque, <span class="type">Dict</span>, <span class="type">Union</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"><span class="keyword">from</span> telegram <span class="keyword">import</span> Update</span><br><span class="line"><span class="keyword">from</span> telegram.ext <span class="keyword">import</span> (</span><br><span class="line">    Application,</span><br><span class="line">    CommandHandler,</span><br><span class="line">    ContextTypes,</span><br><span class="line">    MessageHandler,</span><br><span class="line">    filters,</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>请确保您已经安装了 Telegram Bot API 和 OpenAI Python 库。</p><h2 id="步骤-3：设置-API-密钥和-Telegram-令牌-🔑"><a href="#步骤-3：设置-API-密钥和-Telegram-令牌-🔑" class="headerlink" title="步骤 3：设置 API 密钥和 Telegram 令牌 🔑"></a>步骤 3：设置 API 密钥和 Telegram 令牌 🔑</h2><p>在这一步，我们需要设置 OpenAI API 密钥和 Telegram 机器人令牌。确保您已经注册了 OpenAI 并获取了 API 密钥。然后，将下面的示例代码中的 API 密钥和 Telegram 令牌替换为您自己的：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openai.api_key = <span class="string">"您的 OpenAI API 密钥"</span></span><br><span class="line">TOKEN: Final = <span class="string">"您的 Telegram 机器人令牌"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="步骤-4：创建启动和帮助命令-🚀"><a href="#步骤-4：创建启动和帮助命令-🚀" class="headerlink" title="步骤 4：创建启动和帮助命令 🚀"></a>步骤 4：创建启动和帮助命令 🚀</h2><p>接下来，我们将创建两个命令处理函数，用于处理启动和帮助命令。这些命令允许用户与机器人进行互动。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">start_command</span>(<span class="params">update: Update, context: ContextTypes.DEFAULT_TYPE</span>):</span><br><span class="line">    <span class="keyword">await</span> update.message.reply_text(<span class="string">"你好世界! 😄"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">help_command</span>(<span class="params">update: Update, context: ContextTypes.DEFAULT_TYPE</span>):</span><br><span class="line">    <span class="keyword">await</span> update.message.reply_text(<span class="string">"我是 PunShine Bot，我可以帮你找到最搞笑的双关语！ 😂"</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>start_command</code> 函数用于处理启动命令，当用户发送 <code>/start</code> 命令时，机器人将回复 “你好世界! 😄”。<code>help_command</code> 函数用于处理帮助命令，当用户发送 <code>/help</code> 命令时，机器人将回复帮助信息。</p><h2 id="步骤-5：处理用户消息-📨"><a href="#步骤-5：处理用户消息-📨" class="headerlink" title="步骤 5：处理用户消息 📨"></a>步骤 5：处理用户消息 📨</h2><p>在这一步，我们定义了处理用户消息的 <code>handle_response</code> 函数，并创建了消息处理程序 <code>message_handler</code>。这个函数将用户的消息添加到对话历史记录中，并使用 OpenAI API 生成机器人的回复。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_response</span>(<span class="params">chat_id: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>], text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># 获取聊天历史记录</span></span><br><span class="line">    chat_history = get_chat_history(chat_id)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建用户消息</span></span><br><span class="line">    user_message = {<span class="string">"role"</span>: <span class="string">"user"</span>, <span class="string">"content"</span>: text}</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将用户消息添加到聊天历史记录</span></span><br><span class="line">    chat_history.append(user_message)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建消息列表，包括系统消息和用户消息</span></span><br><span class="line">    messages = [</span><br><span class="line">        {</span><br><span class="line">            <span class="string">"role"</span>: <span class="string">"system"</span>,</span><br><span class="line">            <span class="string">"content"</span>: <span class="string">"你是 PunshineBot，用中文回答，语气随意，别太正式，多用 emoji，回复要简短一点。 😄🚀"</span>,</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">    messages.extend(chat_history)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用 OpenAI API 生成机器人的回复</span></span><br><span class="line">    response = openai.ChatCompletion.create(</span><br><span class="line">        model=<span class="string">"gpt-3.5-turbo"</span>,</span><br><span class="line">        messages=messages,</span><br><span class="line">        temperature=<span class="number">1</span>,</span><br><span class="line">        max_tokens=<span class="number">256</span>,</span><br><span class="line">        top_p=<span class="number">1</span>,</span><br><span class="line">        frequency_penalty=<span class="number">0</span>,</span><br><span class="line">        presence_penalty=<span class="number">0</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    bot_response = response[<span class="string">"choices"</span>][<span class="number">0</span>][<span class="string">"message"</span>][<span class="string">"content"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将机器人的回复添加到对话历史记录</span></span><br><span class="line">    chat_history.append({<span class="string">"role"</span>: <span class="string">"assistant"</span>, <span class="string">"content"</span>: bot_response})</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bot_response</span><br></pre></td></tr></tbody></table></figure><p><code>handle_response</code> 函数将用户消息添加到对话历史记录中，然后使用 OpenAI API 生成机器人的回复，并将机器人的回复添加到对话历史记录中，以保持上下文。</p><p><code>message_handler</code> 函数用于处理用户发送的消息。它检查消息的类型（群组消息或私聊消息）以及消息的内容，然后调用 <code>handle_response</code> 函数生成机器人的回复。</p><h2 id="步骤-6：运行-Telegram-机器人-🚀"><a href="#步骤-6：运行-Telegram-机器人-🚀" class="headerlink" title="步骤 6：运行 Telegram 机器人 🚀"></a>步骤 6：运行 Telegram 机器人 🚀</h2><p>最后，在主函数中，我们创建了一个 Telegram 机器人应用程序，并添加了命令处理程序和消息处理程序。然后，我们启动了 Telegram 机器人，使其可以接收和处理消息。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = Application.builder().token(TOKEN).build()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加命令处理程序</span></span><br><span class="line">    app.add_handler(CommandHandler(<span class="string">"start"</span>, start_command))</span><br><span class="line">    app.add_handler(CommandHandler(<span class="string">"help"</span>, help_command))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加消息处理程序</span></span><br><span class="line">    app.add_handler(MessageHandler(filters.TEXT, callback=message_handler))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动 Telegram 机器人</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"机器人已启动！ 😎🤖"</span>)</span><br><span class="line">    app.run_polling(poll_interval=<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><img src="/2023/09/24/NLP%20Insights/%E5%8D%81%E5%88%86%E9%92%9F%E7%94%A8%20Python%20%E5%92%8C%20OpenAI%20%E5%88%9B%E5%BB%BA%20Telegram%20%E6%9C%BA%E5%99%A8%E4%BA%BA/step6_zh.jpg" class=""><p><code>app.run_polling(poll_interval=1)</code> 启动了 Telegram 机器人，以每秒的间隔轮询新消息。这意味着机器人会一直运行，并在接收到消息时触发相应的处理程序。</p><h2 id="步骤-7：免费在线托管您的-Telegram-机器人-24-x2F-7-🚀"><a href="#步骤-7：免费在线托管您的-Telegram-机器人-24-x2F-7-🚀" class="headerlink" title="步骤 7：免费在线托管您的 Telegram 机器人 24/7 🚀"></a>步骤 7：免费在线托管您的 Telegram 机器人 24/7 🚀</h2><p>在之前的教程中，我们教您如何创建一个 Telegram 机器人。但是，要使您的机器人一直在线运行，您需要让您的计算机保持开启，这可能不太方便。在这篇博客中，我们将向您展示如何将您的机器人免费托管在云服务器上，以便您的机器人可以全天候在线运行。</p><p>PythonAnywhere 是一个允许您免费托管 Python 代码的网站，它具有一定的使用限制，但对于简单的用途来说，非常合适。在这里，我们将展示如何使用 PythonAnywhere 来托管您的 Telegram 机器人。</p><p>访问 <a href="https://www.pythonanywhere.com/">PythonAnywhere 网站</a> 并创建一个帐户。</p><img src="/2023/09/24/NLP%20Insights/%E5%8D%81%E5%88%86%E9%92%9F%E7%94%A8%20Python%20%E5%92%8C%20OpenAI%20%E5%88%9B%E5%BB%BA%20Telegram%20%E6%9C%BA%E5%99%A8%E4%BA%BA/step7.jpg" class=""><h3 id="7-1：创建一个-Python-脚本"><a href="#7-1：创建一个-Python-脚本" class="headerlink" title="7.1：创建一个 Python 脚本"></a>7.1：创建一个 Python 脚本</h3><p>一旦您登录到 PythonAnywhere 的仪表板，您将看到一个名为 “Files” 的选项。点击它，然后创建一个新文件，我们将命名它为 “telegram_bot.py”。在这个文件中，我们将粘贴之前创建的 Telegram 机器人代码。</p><h3 id="7-2：安装所需的包"><a href="#7-2：安装所需的包" class="headerlink" title="7.2：安装所需的包"></a>7.2：安装所需的包</h3><p>在运行 Telegram 机器人之前，我们需要安装所需的 Python 包。PythonAnywhere 提供了一个命令行界面，您可以在其中执行以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install python-telegram-bot</span><br><span class="line">pip install openai</span><br></pre></td></tr></tbody></table></figure><p>这将安装 Telegram 机器人库，使您的代码能够与 Telegram 服务器通信。</p><h3 id="7-3：运行机器人"><a href="#7-3：运行机器人" class="headerlink" title="7.3：运行机器人"></a>7.3：运行机器人</h3><p>现在，您可以返回到 PythonAnywhere 的仪表板，并在 “Files” 下找到您的 “telegram_bot.py” 文件。然后，点击 “Run” 按钮，您的机器人将开始运行。机器人将一直在线，即使您关闭了计算机也是如此。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>现在，您已经掌握了如何创建一个 Python Telegram 机器人，并与 OpenAI 集成，使其能够回应用户的消息并生成回复。通过这个简单的步骤，您可以将您的 Telegram 机器人免费托管在云服务器上，以便它可以全天候在线运行。这样，您就可以与您的机器人互动，而不必担心计算机是否开启。如果您有其他免费托管服务或其他问题，欢迎在评论中分享！祝您的机器人运行愉快！🤖🚀😄</p><p>另外，如果您想了解更多关于如何在 Discord 上托管机器人的信息，可以观看此 YouTube 视频：<a href="https://www.youtube.com/watch?v=2TI-tCVhe9k">How To Host Your Bot Online 24/7 For FREE With Python (Telegram, Discord, Etc)</a>。视频中有更详细的教程和示例。</p><p>如果您有任何问题或需要进一步的帮助，请随时留下评论。祝您编程愉快！ 🚀🤖😄</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://www.youtube.com/watch?v=vZtm1wuA2yc">How To Create A Telegram Bot In Python For Beginners (2023 Tutorial)</a></li><li><a href="https://www.youtube.com/watch?v=2TI-tCVhe9k">How To Host Your Bot Online 24/7 For FREE With Python (Telegram, Discord, Etc)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🤖-十分钟用-Python-和-OpenAI-创建-Telegram-机器人！-🚀&quot;&gt;&lt;a href=&quot;#🤖-十分钟用-Python-和-OpenAI-创建-Telegram-机器人！-🚀&quot; class=&quot;headerlink&quot; title=&quot;🤖 十分钟</summary>
      
    
    
    
    <category term="Code Chronicles" scheme="https://chenhuiyu.github.io/categories/Code-Chronicles/"/>
    
    
    <category term="Chatbot" scheme="https://chenhuiyu.github.io/tags/Chatbot/"/>
    
  </entry>
  
  <entry>
    <title>Resolving Port Conflicts: Identifying and Terminating Processes</title>
    <link href="https://chenhuiyu.github.io/2023/09/13/Debugging%20Diaries/Resolving%20Port%20Conflicts:%20Identifying%20and%20Terminating%20Processes/"/>
    <id>https://chenhuiyu.github.io/2023/09/13/Debugging%20Diaries/Resolving%20Port%20Conflicts:%20Identifying%20and%20Terminating%20Processes/</id>
    <published>2023-09-13T04:10:55.000Z</published>
    <updated>2023-09-13T04:11:07.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Resolving-Port-Conflicts-Identifying-and-Terminating-Processes"><a href="#Resolving-Port-Conflicts-Identifying-and-Terminating-Processes" class="headerlink" title="Resolving Port Conflicts: Identifying and Terminating Processes"></a>Resolving Port Conflicts: Identifying and Terminating Processes</h1><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li>Introduction 📝</li><li>Finding Processes on Windows 🕵️‍♂️</li><li>Finding Processes on Linux/macOS 🐧</li><li>Viewing Process Details 📊</li><li>Terminating Processes ⛔️</li></ul><h3 id="Introduction-📝"><a href="#Introduction-📝" class="headerlink" title="Introduction 📝"></a>Introduction 📝</h3><p>Sometimes, when you try to start an application or service, you may encounter an “Address already in use” error. This means that the specified port is already in use by another process. To resolve this issue, you need to identify which process is using that port and decide whether to terminate it or change the port configuration of your application.</p><h3 id="Finding-Processes-on-Windows-🕵️‍♂️"><a href="#Finding-Processes-on-Windows-🕵️‍♂️" class="headerlink" title="Finding Processes on Windows 🕵️‍♂️"></a>Finding Processes on Windows 🕵️‍♂️</h3><p>On Windows, you can use the Command Prompt to find the process that is using a specific port. Open the Command Prompt and run the following command:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr :8080</span><br></pre></td></tr></tbody></table></figure><p>This command will list all processes using port 8080 and display their Process ID (PID).</p><h3 id="Finding-Processes-on-Linux-x2F-macOS-🐧"><a href="#Finding-Processes-on-Linux-x2F-macOS-🐧" class="headerlink" title="Finding Processes on Linux/macOS 🐧"></a>Finding Processes on Linux/macOS 🐧</h3><p>On Linux and macOS systems, you can use the terminal to find the process using a specific port. Open the terminal and run the following command:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -i :8080</span><br></pre></td></tr></tbody></table></figure><p>This command will list all processes using port 8080 and display detailed information, including the PID and process name.</p><h3 id="Viewing-Process-Details-📊"><a href="#Viewing-Process-Details-📊" class="headerlink" title="Viewing Process Details 📊"></a>Viewing Process Details 📊</h3><p>Once you have the PID of the process, you can further view details about the process. On Linux and macOS, use the following command:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -p &lt;PID&gt;</span><br></pre></td></tr></tbody></table></figure><p>On Windows, you can use the Task Manager or run the following command (replace <code>&lt;PID&gt;</code> with the correct PID):</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | findstr &lt;PID&gt;</span><br></pre></td></tr></tbody></table></figure><p>This will display detailed information about the process associated with the specified PID, including the process name and other relevant details.</p><h3 id="Terminating-Processes-⛔️"><a href="#Terminating-Processes-⛔️" class="headerlink" title="Terminating Processes ⛔️"></a>Terminating Processes ⛔️</h3><p>If you decide to terminate the process that is using a specific port, follow these steps:</p><p>On Windows, you can use the Task Manager or run the following command (replace <code>&lt;PID&gt;</code> with the correct PID):</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /F /PID &lt;PID&gt;</span><br></pre></td></tr></tbody></table></figure><p>On Linux and macOS, you can run the following command (replace <code>&lt;PID&gt;</code> with the correct PID):</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kill &lt;PID&gt;</span><br></pre></td></tr></tbody></table></figure><p>Please note that terminating a process may interrupt running applications or services, so use this operation carefully. Ensure that you know which process to terminate and avoid impacting critical system processes.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Resolving-Port-Conflicts-Identifying-and-Terminating-Processes&quot;&gt;&lt;a href=&quot;#Resolving-Port-Conflicts-Identifying-and-Terminating-Proce</summary>
      
    
    
    
    <category term="Debugging Diaries" scheme="https://chenhuiyu.github.io/categories/Debugging-Diaries/"/>
    
    
    <category term="IssueFix" scheme="https://chenhuiyu.github.io/tags/IssueFix/"/>
    
  </entry>
  
  <entry>
    <title>解决端口冲突：查找并终止进程</title>
    <link href="https://chenhuiyu.github.io/2023/09/13/Debugging%20Diaries/%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81%EF%BC%9A%E6%9F%A5%E6%89%BE%E5%B9%B6%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B/"/>
    <id>https://chenhuiyu.github.io/2023/09/13/Debugging%20Diaries/%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E5%86%B2%E7%AA%81%EF%BC%9A%E6%9F%A5%E6%89%BE%E5%B9%B6%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B/</id>
    <published>2023-09-13T04:10:55.000Z</published>
    <updated>2023-09-13T04:10:20.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决端口冲突：查找并终止进程"><a href="#解决端口冲突：查找并终止进程" class="headerlink" title="解决端口冲突：查找并终止进程"></a>解决端口冲突：查找并终止进程</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>简介</li><li>在Windows上查找进程 🕵️‍♂️</li><li>在Linux/macOS上查找进程 🐧</li><li>查看进程详细信息 📊</li><li>终止进程 ⛔️</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>有时候，当你尝试启动一个应用程序或服务时，可能会遇到”Address already in use”（地址已经在使用）的错误，这意味着指定的端口已经被另一个进程占用。为了解决这个问题，你需要确定哪个进程正在使用该端口，并可以选择终止该进程或更改应用程序的端口配置。</p><h3 id="在Windows上查找进程-🕵️‍♂️"><a href="#在Windows上查找进程-🕵️‍♂️" class="headerlink" title="在Windows上查找进程 🕵️‍♂️"></a>在Windows上查找进程 🕵️‍♂️</h3><p>在Windows上，你可以使用命令提示符来查找正在使用特定端口的进程。打开命令提示符，并执行以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr :8080</span><br></pre></td></tr></tbody></table></figure><p>这个命令会列出所有正在使用端口8080的进程，并显示它们的进程ID（PID）。</p><h3 id="在Linux-x2F-macOS上查找进程-🐧"><a href="#在Linux-x2F-macOS上查找进程-🐧" class="headerlink" title="在Linux/macOS上查找进程 🐧"></a>在Linux/macOS上查找进程 🐧</h3><p>在Linux和macOS系统上，你可以使用终端来查找正在使用特定端口的进程。打开终端，并执行以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -i :8080</span><br></pre></td></tr></tbody></table></figure><p>这个命令会列出所有使用端口8080的进程，并显示它们的详细信息，包括PID和进程名。</p><h3 id="查看进程详细信息-📊"><a href="#查看进程详细信息-📊" class="headerlink" title="查看进程详细信息 📊"></a>查看进程详细信息 📊</h3><p>一旦你获得了进程的PID，你可以进一步查看有关进程的详细信息。在Linux和macOS上，使用以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -p &lt;PID&gt;</span><br></pre></td></tr></tbody></table></figure><p>在Windows上，你可以使用任务管理器或执行以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | findstr &lt;PID&gt;</span><br></pre></td></tr></tbody></table></figure><p>这将显示与特定PID相关的进程的详细信息，包括进程名称和其他详细信息。</p><h3 id="终止进程-⛔️"><a href="#终止进程-⛔️" class="headerlink" title="终止进程 ⛔️"></a>终止进程 ⛔️</h3><p>如果你确定要终止正在使用特定端口的进程，可以执行以下步骤：</p><p>在Windows上，你可以使用任务管理器或执行以下命令（使用正确的PID替换<pid>）：</pid></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /F /PID &lt;PID&gt;</span><br></pre></td></tr></tbody></table></figure><p>在Linux和macOS上，你可以执行以下命令（使用正确的PID替换<pid>）：</pid></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kill &lt;PID&gt;</span><br></pre></td></tr></tbody></table></figure><p>请注意，终止进程可能会导致正在运行的应用程序或服务中断，因此请谨慎使用此操作。确保你知道终止哪个进程，并确保不会影响到重要的系统进程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解决端口冲突：查找并终止进程&quot;&gt;&lt;a href=&quot;#解决端口冲突：查找并终止进程&quot; class=&quot;headerlink&quot; title=&quot;解决端口冲突：查找并终止进程&quot;&gt;&lt;/a&gt;解决端口冲突：查找并终止进程&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot;</summary>
      
    
    
    
    <category term="Debugging Diaries" scheme="https://chenhuiyu.github.io/categories/Debugging-Diaries/"/>
    
    
    <category term="IssueFix" scheme="https://chenhuiyu.github.io/tags/IssueFix/"/>
    
  </entry>
  
  <entry>
    <title>Towards Open-World Recommendation with KnowledgeAugmentation from Large Language Models</title>
    <link href="https://chenhuiyu.github.io/2023/08/29/NLP%20Insights/Towards%20Open-World%20Recommendation%20with%20KnowledgeAugmentation%20from%20Large%20Language%20Models/"/>
    <id>https://chenhuiyu.github.io/2023/08/29/NLP%20Insights/Towards%20Open-World%20Recommendation%20with%20KnowledgeAugmentation%20from%20Large%20Language%20Models/</id>
    <published>2023-08-29T06:53:29.000Z</published>
    <updated>2023-08-29T06:54:03.225Z</updated>
    
    
    
    
    <category term="NLP Insights" scheme="https://chenhuiyu.github.io/categories/NLP-Insights/"/>
    
    
    <category term="LLM" scheme="https://chenhuiyu.github.io/tags/LLM/"/>
    
    <category term="Recommendation" scheme="https://chenhuiyu.github.io/tags/Recommendation/"/>
    
  </entry>
  
  <entry>
    <title>CTRL:Connect Tabular and Language Model for CTR Prediction</title>
    <link href="https://chenhuiyu.github.io/2023/08/29/NLP%20Insights/Connect%20Tabular%20and%20Language%20Model%20for%20CTR%20Prediction/"/>
    <id>https://chenhuiyu.github.io/2023/08/29/NLP%20Insights/Connect%20Tabular%20and%20Language%20Model%20for%20CTR%20Prediction/</id>
    <published>2023-08-29T03:15:29.000Z</published>
    <updated>2023-08-30T06:35:33.292Z</updated>
    
    
    
    
    <category term="NLP Insights" scheme="https://chenhuiyu.github.io/categories/NLP-Insights/"/>
    
    
    <category term="LLM" scheme="https://chenhuiyu.github.io/tags/LLM/"/>
    
    <category term="Recommendation" scheme="https://chenhuiyu.github.io/tags/Recommendation/"/>
    
  </entry>
  
  <entry>
    <title>无断开烦恼！远程服务器后台运行程序的3种方法：`nohup`、`tmux`和`screen`</title>
    <link href="https://chenhuiyu.github.io/2023/08/23/Code%20Chronicles/Python-Uninterrupted%20Remote%20Program%20Execution:%203%20Methods/"/>
    <id>https://chenhuiyu.github.io/2023/08/23/Code%20Chronicles/Python-Uninterrupted%20Remote%20Program%20Execution:%203%20Methods/</id>
    <published>2023-08-23T06:46:03.000Z</published>
    <updated>2023-08-23T06:46:56.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无断开烦恼！远程服务器后台运行程序的3种方法：nohup、tmux和screen"><a href="#无断开烦恼！远程服务器后台运行程序的3种方法：nohup、tmux和screen" class="headerlink" title="无断开烦恼！远程服务器后台运行程序的3种方法：nohup、tmux和screen"></a>无断开烦恼！远程服务器后台运行程序的3种方法：<code>nohup</code>、<code>tmux</code>和<code>screen</code></h1><h1 id="Uninterrupted-Remote-Program-Execution-3-Methods"><a href="#Uninterrupted-Remote-Program-Execution-3-Methods" class="headerlink" title="Uninterrupted Remote Program Execution: 3 Methods"></a>Uninterrupted Remote Program Execution: 3 Methods</h1><p>在数据分析或机器学习项目中，经常需要在远程服务器上运行耗时长、计算密集型的任务。通过SSH连接到远程服务器是常见的操作方式。但是，如何确保在断开SSH连接之后，远程服务器上的程序能够继续运行呢？本文详细介绍了三种方法：<code>nohup</code>、<code>tmux</code>和<code>screen</code>。</p><h2 id="使用nohup命令"><a href="#使用nohup命令" class="headerlink" title="使用nohup命令"></a>使用<code>nohup</code>命令</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ol><li><p><strong>连接到远程机器</strong>：在本地终端中执行以下命令。</p> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@remote-server-address</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>启动后台程序</strong>：在远程机器上执行。</p> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> your-command-to-run-the-program &amp;</span><br></pre></td></tr></tbody></table></figure></li></ol><p>例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> python train_model.py &amp;</span><br></pre></td></tr></tbody></table></figure><p>此方法会将程序的输出重定向到一个名为<code>nohup.out</code>的文件中。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>在远程机器上执行以下命令。</p><ol><li><p>**查找程序的进程ID (PID)**：</p> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep your-command-to-run-the-program</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>结束进程</strong>：</p> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>输出含义</strong>:<br>当你执行如下命令：</p></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> python train_model.py &amp;</span><br></pre></td></tr></tbody></table></figure><p>你可能会看到这样的输出：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1] 337082</span><br><span class="line"><span class="built_in">nohup</span>: ignoring input and appending output to <span class="string">'nohup.out'</span></span><br></pre></td></tr></tbody></table></figure><p>这里，</p><ul><li><strong><a href="%E8%BF%99%E6%98%AF%E8%AF%A5%E5%90%8E%E5%8F%B0%E4%BD%9C%E4%B8%9A%E7%9A%84%E4%BD%9C%E4%B8%9A%E7%BC%96%E5%8F%B7%E3%80%82%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E4%BD%9C%E4%B8%9A%EF%BC%8C%E6%AF%8F%E4%B8%AA%E4%BD%9C%E4%B8%9A%E9%83%BD%E4%BC%9A%E6%9C%89%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E7%9A%84%E4%BD%9C%E4%B8%9A%E7%BC%96%E5%8F%B7%E3%80%82">1</a> 337082</strong> 表示该任务现在在后台运行，PID（进程ID）为337082。<ul><li></li><li>337082: 这是该后台作业对应的进程ID (PID)。你可以使用这个PID来监视或结束该进程。</li></ul></li><li><strong>nohup: ignoring input and appending output to ‘nohup.out’</strong> 表示该进程现在将忽略任何输入，并将输出追加到 <code>nohup.out</code> 文件。<ul><li>这是 <code>nohup</code> 命令的标准消息，含义如下：<ul><li><code>ignoring input</code>: 当你使用 <code>nohup</code> 命令，它将不会接收任何从终端输入的数据。这意味着，一旦你使用 <code>nohup</code> 启动了一个程序，你不能再向它提供任何交互式输入（除非程序有其他的输入方法）。</li><li><code>appending output to 'nohup.out'</code>: 默认情况下，<code>nohup</code> 会将程序的输出重定向到一个名为 <code>nohup.out</code> 的文件中。所以，如果你的程序在执行过程中产生了任何输出（如打印语句），这些输出都会被写入到 <code>nohup.out</code> 文件中。如果该文件之前不存在，<code>nohup</code> 会自动创建它；如果文件已存在，<code>nohup</code> 会将新的输出追加到文件的末尾。</li><li>如果你想查看程序的输出，你可以使用 <code>cat</code> 或 <code>tail</code> 命令来查看 <code>nohup.out</code> 文件的内容。例如，使用 <code>tail -f nohup.out</code> 可以实时查看该文件的末尾内容，这对于监视程序的运行状态很有用。</li></ul></li></ul></li></ul><h2 id="使用tmux"><a href="#使用tmux" class="headerlink" title="使用tmux"></a>使用<code>tmux</code></h2><h3 id="开始-1"><a href="#开始-1" class="headerlink" title="开始"></a>开始</h3><ol><li>**安装<code>tmux</code>**：在远程机器上执行以下命令。</li></ol><ul><li>Ubuntu/Debian  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tmux <span class="comment"># Ubuntu/Debian</span></span><br></pre></td></tr></tbody></table></figure></li><li>MacOS  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install tmux</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="2"><li><p><strong>连接到远程机器</strong>：在本地终端中执行。</p> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@remote-server-address</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>开始新的tmux会话</strong>：在远程机器上执行。</p> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux</span><br></pre></td></tr></tbody></table></figure></li></ol><p>然后在tmux会话内运行您的程序。</p><ol start="4"><li><strong>断开会话</strong>：在远程机器上按 <code>Ctrl+b d</code>。</li></ol><h3 id="结束-1"><a href="#结束-1" class="headerlink" title="结束"></a>结束</h3><p>在远程机器上执行以下命令。</p><ol><li><p><strong>重新连接到tmux会话</strong>：</p> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux attach</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>结束程序和会话</strong>：使用<code>Ctrl+c</code>结束程序，然后按<code>Ctrl+b</code>再按<code>x</code>结束tmux会话。</p></li></ol><h2 id="使用screen"><a href="#使用screen" class="headerlink" title="使用screen"></a>使用<code>screen</code></h2><h3 id="开始-2"><a href="#开始-2" class="headerlink" title="开始"></a>开始</h3><ol><li>**安装<code>screen</code>**：在本地终端中执行。</li></ol><ul><li>Ubuntu/Debian  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install screen <span class="comment"># Ubuntu/Debian</span></span><br></pre></td></tr></tbody></table></figure></li><li>MacOS  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install screen</span><br></pre></td></tr></tbody></table></figure></li></ul><ol><li><p><strong>连接到远程机器</strong>：在本地终端中执行。</p> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@remote-server-address</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>开始新的screen会话</strong>：在远程机器上执行。</p> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></tbody></table></figure></li></ol><p>然后在screen会话内运行您的程序。</p><ol start="4"><li><strong>断开会话</strong>：在远程机器上按 <code>Ctrl+a d</code>。</li></ol><h3 id="结束-2"><a href="#结束-2" class="headerlink" title="结束"></a>结束</h3><p>在远程机器上执行以下命令。</p><ol><li><p><strong>重新连接到screen会话</strong>：</p> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>结束程序和会话</strong>：使用<code>Ctrl+c</code>结束程序，然后按<code>Ctrl+a</code>再按<code>k</code>结束screen会话。</p></li></ol><h2 id="特殊情况：macOS用户"><a href="#特殊情况：macOS用户" class="headerlink" title="特殊情况：macOS用户"></a>特殊情况：macOS用户</h2><p>macOS用户可以使用Homebrew来安装<code>tmux</code>或<code>screen</code>。</p><ul><li><p>安装<code>tmux</code>：</p>  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install tmux</span><br></pre></td></tr></tbody></table></figure></li><li><p>安装<code>screen</code>：</p>  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install screen</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;无断开烦恼！远程服务器后台运行程序的3种方法：nohup、tmux和screen&quot;&gt;&lt;a href=&quot;#无断开烦恼！远程服务器后台运行程序的3种方法：nohup、tmux和screen&quot; class=&quot;headerlink&quot; title=&quot;无断开烦恼！远程服务器后</summary>
      
    
    
    
    <category term="Code Chronicles" scheme="https://chenhuiyu.github.io/categories/Code-Chronicles/"/>
    
    
    <category term="Python Basic" scheme="https://chenhuiyu.github.io/tags/Python-Basic/"/>
    
  </entry>
  
  <entry>
    <title>超越Python的边界：`subprocess` 助你一键执行外部命令</title>
    <link href="https://chenhuiyu.github.io/2023/08/22/Code%20Chronicles/Python-subprocess/"/>
    <id>https://chenhuiyu.github.io/2023/08/22/Code%20Chronicles/Python-subprocess/</id>
    <published>2023-08-22T11:06:03.000Z</published>
    <updated>2023-08-23T06:33:28.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="超越Python的边界：subprocess-助你一键执行外部命令"><a href="#超越Python的边界：subprocess-助你一键执行外部命令" class="headerlink" title="超越Python的边界：subprocess 助你一键执行外部命令"></a>超越Python的边界：<code>subprocess</code> 助你一键执行外部命令</h1><p>在日常开发中，有时候我们希望能够从 Python 脚本中执行系统命令或者其他程序。Python 提供了 <code>subprocess</code> 模块，使得这一操作变得既简单又安全。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>subprocess</code> 模块是 Python 标准库的一部分，它提供了一种简单统一的方法来执行外部命令，与进程交互，读取它的输出，并获取它的返回码。无论你是在自动化某个系统任务，还是简单地想要从另一个程序中获取数据，<code>subprocess</code> 都能助你一臂之力。</p><h2 id="功能与用途"><a href="#功能与用途" class="headerlink" title="功能与用途"></a>功能与用途</h2><ol><li><p><strong>执行外部命令</strong>：你可以轻易地从 Python 脚本中运行任何外部命令，就像在命令行中输入命令一样。这种能力使得你能够在你的 Python 程序中调用并集成其他命令行工具，扩展你的应用的功能。</p></li><li><p><strong>捕获命令的输出</strong>：如果你想获取命令的输出并在 Python 脚本中处理，<code>subprocess</code> 也能满足你。你可以将命令的输出作为字符串捕获，然后进一步分析和处理，这在需要对命令输出进行解析或者提取时非常有用。</p></li><li><p><strong>错误处理</strong>：通过捕获返回码，你可以知道命令是否成功执行，或者是否发生了错误。这使得你能够根据命令的执行结果采取不同的操作，从而提高程序的健壮性。</p></li><li><p><strong>与进程交互</strong>：<code>subprocess</code> 不仅可以启动和停止进程，还可以与它们进行双向通信。这使得你能够在运行的外部进程中发送输入，并从其输出中获取数据，从而实现更高级的交互和控制。</p></li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="基本的命令执行"><a href="#基本的命令执行" class="headerlink" title="基本的命令执行"></a>基本的命令执行</h3><p>执行命令最简单的方法是使用 <code>subprocess.run()</code> 函数，它接受一个命令及其参数的列表，并返回一个 <code>CompletedProcess</code> 对象，其中包含了命令执行的结果。这使得你能够轻松地在你的脚本中运行外部命令，例如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">result = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-l'</span>])</span><br></pre></td></tr></tbody></table></figure><h3 id="捕获命令输出"><a href="#捕获命令输出" class="headerlink" title="捕获命令输出"></a>捕获命令输出</h3><p>想要捕获命令的输出到 Python 脚本中，可以设置 <code>capture_output=True</code> 参数。此外，通过设置 <code>text=True</code> 参数，你可以以文本形式获取命令的输出：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = subprocess.run([<span class="string">'ls'</span>, <span class="string">'-l'</span>], capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(result.stdout)</span><br></pre></td></tr></tbody></table></figure><h3 id="使用-shell"><a href="#使用-shell" class="headerlink" title="使用 shell"></a>使用 shell</h3><p>当你需要执行包含 shell 功能（例如管道或通配符）的命令时，可以设置 <code>shell=True</code> 参数，并将命令作为字符串传递给 <code>subprocess.run()</code>。这样，你可以执行更复杂的命令，如以下示例所示：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = subprocess.run(<span class="string">'ls -l | grep "my_file"'</span>, shell=<span class="literal">True</span>, capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(result.stdout)</span><br></pre></td></tr></tbody></table></figure><p><strong>警告</strong>：虽然 <code>shell=True</code> 参数很有用，但使用时必须小心，因为它可能会让你的代码暴露于命令注入攻击。确保永远不要执行包含不受信任的输入的命令。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>命令如果返回一个非零的退出码，可以通过 <code>check=True</code> 参数来抛出异常。这使得你能够捕获命令执行过程中的错误，从而进行适当的处理：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = subprocess.run([<span class="string">'ls'</span>, <span class="string">'non_existent_file'</span>], check=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">except</span> subprocess.CalledProcessError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"命令执行出错!"</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>subprocess</code> 模块是 Python 中执行外部命令的强大工具。通过它，开发者可以轻松地与操作系统及其他应用程序交互，扩展程序的功能。然而，在使用 <code>subprocess</code> 时需要注意命令的安全性，以避免潜在的安全风险。通过合理地利用 <code>subprocess</code> 模块，你可以更好地管理外部命令的执行，并将其融入到你的 Python 应用中，提升开发效率。希望本文能够帮助你更深入地理解和使用 <code>subprocess</code> 模块的种种功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;超越Python的边界：subprocess-助你一键执行外部命令&quot;&gt;&lt;a href=&quot;#超越Python的边界：subprocess-助你一键执行外部命令&quot; class=&quot;headerlink&quot; title=&quot;超越Python的边界：subprocess 助你一</summary>
      
    
    
    
    <category term="Code Chronicles" scheme="https://chenhuiyu.github.io/categories/Code-Chronicles/"/>
    
    
    <category term="Python Basic" scheme="https://chenhuiyu.github.io/tags/Python-Basic/"/>
    
  </entry>
  
  <entry>
    <title>Conver Pytorch Model to ONNX Format</title>
    <link href="https://chenhuiyu.github.io/2023/08/21/NLP%20Insights/Conver%20Pytorch%20Model%20to%20ONNX%20Format/"/>
    <id>https://chenhuiyu.github.io/2023/08/21/NLP%20Insights/Conver%20Pytorch%20Model%20to%20ONNX%20Format/</id>
    <published>2023-08-21T06:34:18.000Z</published>
    <updated>2023-08-21T06:36:38.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-PyTorch-和-ONNX-检查模型一致性"><a href="#使用-PyTorch-和-ONNX-检查模型一致性" class="headerlink" title="使用 PyTorch 和 ONNX 检查模型一致性"></a>使用 PyTorch 和 ONNX 检查模型一致性</h1><p>在机器学习和深度学习的开发过程中，模型的互操作性变得越来越重要。ONNX (Open Neural Network Exchange) 是一种开放格式，用于表示机器学习和深度学习模型。它允许开发者在各种深度学习框架之间轻松地共享模型，从而提高了模型的可移植性和互操作性。</p><p>本教程将指导您完成以下步骤：</p><ol><li>将 PyTorch 模型转换为 ONNX 格式。</li><li>验证转换后的 ONNX 模型与原始 PyTorch 模型的输出是否一致。</li></ol><h2 id="1-导入必要的库"><a href="#1-导入必要的库" class="headerlink" title="1. 导入必要的库"></a>1. 导入必要的库</h2><p>首先，我们导入为模型转换和验证所需的所有库。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> onnx</span><br><span class="line"><span class="keyword">import</span> onnxruntime</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></tbody></table></figure><h2 id="2-定义模型转换函数"><a href="#2-定义模型转换函数" class="headerlink" title="2. 定义模型转换函数"></a>2. 定义模型转换函数</h2><p>为了将 PyTorch 模型转换为 ONNX 格式，我们定义了一个名为 <code>convert_onnx</code> 的函数。此函数使用 PyTorch 的内置函数 <code>torch.onnx.export</code> 将模型转换为 ONNX 格式。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert_onnx</span>(<span class="params">model, dummy_input, onnx_path</span>):</span><br><span class="line">    input_names = [<span class="string">'modelInput'</span>]</span><br><span class="line">    output_names = [<span class="string">"modelOutput"</span>]</span><br><span class="line">    torch.onnx.export(model=model,</span><br><span class="line">                      args=dummy_input,</span><br><span class="line">                      f=onnx_path,</span><br><span class="line">                      opset_version=<span class="number">10</span>,</span><br><span class="line">                      input_names=input_names,</span><br><span class="line">                      output_names=output_names)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>此函数接收三个参数：PyTorch 模型、模拟输入数据以及要保存 ONNX 模型的路径。<code>torch.onnx.export</code> 函数需要模型、输入和保存路径作为参数，以及其他一些可选参数来指定输入和输出的名称。</p><h2 id="3-定义一致性检查函数"><a href="#3-定义一致性检查函数" class="headerlink" title="3. 定义一致性检查函数"></a>3. 定义一致性检查函数</h2><p>一旦我们有了 ONNX 格式的模型，就可以使用 <code>check_consistency</code> 函数来验证 PyTorch 模型和 ONNX 模型的输出是否一致。这是确保转换过程没有引入任何差异的关键步骤。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_consistency</span>(<span class="params">pytorch_model, onnx_model_path, input_tensor, tolerance=<span class="number">1e-6</span></span>):</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        pytorch_output_dict = pytorch_model(input_tensor)</span><br><span class="line">        pytorch_output = pytorch_output_dict[<span class="string">'y_pred'</span>].cpu().numpy()</span><br><span class="line"></span><br><span class="line">    ort_session = onnxruntime.InferenceSession(onnx_model_path)</span><br><span class="line">    ort_inputs = {ort_session.get_inputs()[<span class="number">0</span>].name: input_tensor.cpu().numpy()}</span><br><span class="line">    ort_output = ort_session.run(<span class="literal">None</span>, ort_inputs)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    difference = np.<span class="built_in">abs</span>(pytorch_output - ort_output)</span><br><span class="line">    consistent = np.<span class="built_in">all</span>(difference &lt;= tolerance)</span><br><span class="line">    <span class="keyword">return</span> consistent</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>此函数首先使用 PyTorch 模型计算输出，然后使用 ONNX 运行时计算 ONNX 模型的输出。最后，它比较两个输出，检查它们之间的差异是否在预定义的容忍范围内。</p><h2 id="4-示例调用"><a href="#4-示例调用" class="headerlink" title="4. 示例调用"></a>4. 示例调用</h2><p>为了确保上述函数的正确性，我们提供了一个简单的示例，展示了如何使用上述函数来转换模型并检查一致性。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载 PyTorch 模型 (此处只是一个示例，需要根据实际情况进行修改)</span></span><br><span class="line">model = YOUR_PYTORCH_MODEL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为 ONNX 格式</span></span><br><span class="line">dummy_input = YOUR_INPUT_TENSOR</span><br><span class="line">onnx_path = <span class="string">"path_to_save_onnx_model.onnx"</span></span><br><span class="line">convert_onnx(model, dummy_input, onnx_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查一致性</span></span><br><span class="line">is_consistent = check_consistency(model, onnx_path, dummy_input)</span><br><span class="line"><span class="keyword">if</span> is_consistent:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The outputs of the PyTorch model and the ONNX model are consistent!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"There is a discrepancy between the outputs of the PyTorch model and the ONNX model."</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在实际应用中，确保根据您的实际模型和数据替换 <code>YOUR_PYTORCH_MODEL</code> 和 <code>YOUR_INPUT_TENSOR</code>。</p><hr><p>以上就是关于如何使用 PyTorch 和 ONNX 来检查模型一致性的教程。希望这篇文章对你有所帮助，如果有任何问题，欢迎在下方留言。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用-PyTorch-和-ONNX-检查模型一致性&quot;&gt;&lt;a href=&quot;#使用-PyTorch-和-ONNX-检查模型一致性&quot; class=&quot;headerlink&quot; title=&quot;使用 PyTorch 和 ONNX 检查模型一致性&quot;&gt;&lt;/a&gt;使用 PyTorch </summary>
      
    
    
    
    <category term="NLP Insights" scheme="https://chenhuiyu.github.io/categories/NLP-Insights/"/>
    
    
    <category term="Onnx" scheme="https://chenhuiyu.github.io/tags/Onnx/"/>
    
    <category term="Deployment" scheme="https://chenhuiyu.github.io/tags/Deployment/"/>
    
  </entry>
  
  <entry>
    <title>Training Llama 2 Model on Single GPU with int8 Quantization and LoRA</title>
    <link href="https://chenhuiyu.github.io/2023/08/02/NLP%20Insights/LLAMA2/"/>
    <id>https://chenhuiyu.github.io/2023/08/02/NLP%20Insights/LLAMA2/</id>
    <published>2023-08-02T07:38:29.000Z</published>
    <updated>2023-08-02T08:04:32.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Training-Llama-2-Model-on-Single-GPU-with-int8-Quantization-and-LoRA"><a href="#Training-Llama-2-Model-on-Single-GPU-with-int8-Quantization-and-LoRA" class="headerlink" title="Training Llama 2 Model on Single GPU with int8 Quantization and LoRA"></a>Training Llama 2 Model on Single GPU with int8 Quantization and LoRA</h1><h1 id="Llama-2"><a href="#Llama-2" class="headerlink" title="Llama 2"></a>Llama 2</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><em>Llama 2</em> 是一个包含预训练和微调的生成式文本模型的集合，其规模从 70 亿到 700 亿个参数不等。Llama2模型是由Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert等人在<a href="https://ai.meta.com/research/publications/llama-2-open-foundation-and-fine-tuned-chat-models/">Llama 2: Open Foundation and Fine-Tuned Chat Models</a>中提出的。</p><p>该论文的摘要如下：</p><p>在这项工作中，我们开发并发布了Llama 2，这是一组从70亿到700亿参数的预训练和微调的大型语言模型（LLMs）。我们的微调LLMs，称为Llama 2-Chat，针对对话用例进行了优化。我们的模型在我们测试的大多数基准上胜过开源聊天模型，并且基于我们对有用性和安全性的人类评估，可能是闭源模型的合适替代品。我们提供了关于微调和改进Llama 2-Chat安全性的方法的详细描述，以便社区能够在我们的工作基础上构建，并有助于LLMs的负责任发展。</p><p><a href="https://huggingface.co/models?search=llama2">在此处查看所有Llama2模型</a></p><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul><li>通过填写<a href="https://ai.meta.com/resources/models-and-libraries/llama-downloads/">此表格</a>可以获得Llama2模型的权重</li><li>该架构与第一个Llama非常相似，增加了Groupe Query Attention（GQA）<a href="https://arxiv.org/pdf/2305.13245.pdf">此论文</a>之后</li><li>将<code>config.pretraining_tp</code>设置为不同于1的值将激活线性层的更准确但更慢的计算，这应更好地匹配原始logits。</li><li>原始模型使用<code>pad_id = -1</code>，这意味着没有填充令牌。我们不能使用相同的逻辑，请确保使用<code>tokenizer.add_special_tokens({"pad_token":"&lt;pad&gt;"})</code>添加填充令牌，并相应地调整令牌嵌入大小。您还应设置<code>model.config.pad_token_id</code>。模型的embed_tokens层用<code>self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.config.padding_idx)</code>初始化，确保编码填充令牌将输出零，因此在初始化时传递它是推荐的。</li><li>填写表格并获得模型检查点的访问权限后，您应该能够使用已转换的检查点。否则，如果您正在转换自己的模型，请随时使用转换脚本。可以使用以下（示例）命令调用脚本：<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python src/transformers/models/llama/convert_llama_weights_to_hf.py \</span><br><span class="line">    --input_dir /path/to/downloaded/llama/weights --model_size 7B --output_dir /output/path</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="模型详情"><a href="#模型详情" class="headerlink" title="模型详情"></a>模型详情</h2><p>注意：使用该模型受 Meta 许可证的约束。为了下载模型权重和分词器，请访问网站并在请求访问之前接受许可证。</p><p>Meta 开发并公开发布了 Llama 2 系列大型语言模型（LLMs），这是一系列规模从 70 亿到 700 亿参数的预训练和微调的生成式文本模型。我们的微调 LLMs，称为 Llama-2-Chat，经过优化用于对话应用场景。Llama-2-Chat 模型在我们测试的大多数基准测试中优于开源聊天模型，并在我们的人工评估中在有用性和安全性方面与一些流行的闭源模型（如ChatGPT和PaLM）持平。</p><h2 id="模型开发者"><a href="#模型开发者" class="headerlink" title="模型开发者"></a>模型开发者</h2><p>Model Developers Meta</p><h2 id="不同版本"><a href="#不同版本" class="headerlink" title="不同版本"></a>不同版本</h2><p>Llama 2 有不同规模的参数版本，包括 7B、13B 和 70B，以及预训练和微调的变体。</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>输入模型仅支持文本输入。</p><p>输出模型仅生成文本。</p><h2 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h2><p>Llama 2 是一种自回归语言模型，采用了优化的 Transformer 架构。微调版本使用有监督的微调（SFT）和基于人类反馈的强化学习（RLHF）来与人类对 helpfulness 和 safety 的偏好保持一致。</p><h2 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h2><table><thead><tr><th>模型名称</th><th>训练数据</th><th>参数规模</th><th>内容长度</th><th>GQA</th><th>Tokens</th><th>LR</th></tr></thead><tbody><tr><td>Llama 2</td><td>一种新的公开可用的在线数据混合</td><td>7B</td><td>4k</td><td>✗</td><td>2.0T</td><td>3.0 x 10-4</td></tr><tr><td>Llama 2</td><td>一种新的公开可用的在线数据混合</td><td>13B</td><td>4k</td><td>✗</td><td>2.0T</td><td>3.0 x 10-4</td></tr><tr><td>Llama 2</td><td>一种新的公开可用的在线数据混合</td><td>70B</td><td>4k</td><td>✔</td><td>2.0T</td><td>1.5 x 10-4</td></tr></tbody></table><p>注：Token counts 仅指预训练数据。所有模型都使用全局 batch-size 为 4M tokens 进行训练。规模更大的模型（70B）使用 Grouped-Query Attention（GQA）来提高推理可伸缩性。</p><h2 id="模型训练日期"><a href="#模型训练日期" class="headerlink" title="模型训练日期"></a>模型训练日期</h2><p>Llama 2 在2023年1月至2023年7月之间进行训练。</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>这是一个在离线数据集上训练的静态模型。随着我们根据社区反馈改进模型的安全性，将发布微调版本的未来版本。</p><h2 id="许可证"><a href="#许可证" class="headerlink" title="许可证"></a>许可证</h2><p>定制的商业许可证可在以下网址获取：<a href="https://ai.meta.com/resources/models-and-libraries/llama-downloads/">https://ai.meta.com/resources/models-and-libraries/llama-downloads/</a></p><h2 id="研究论文"><a href="#研究论文" class="headerlink" title="研究论文"></a>研究论文</h2><p>《Llama-2: Open Foundation and Fine-tuned Chat Models》</p><h2 id="使用目的"><a href="#使用目的" class="headerlink" title="使用目的"></a>使用目的</h2><h3 id="预期用途"><a href="#预期用途" class="headerlink" title="预期用途"></a>预期用途</h3><p>Llama 2 旨在用于英语商业和研究用途。微调模型适用于类似助理的聊天应用，而预训练模型可适应多种自然语言生成任务。</p><p>要获得聊天版本的预期功能和性能，需要遵循特定的格式，包括 INST 和 &lt;<sys>&gt; 标签、BOS 和 EOS tokens，以及它们之间的空格和换行符（我们建议对输入调用 strip() 方法，以避免双空格）。有关详情，请参阅我们在 GitHub 上的参考代码：chat_completion。</sys></p><h3 id="不在范围内的用途"><a href="#不在范围内的用途" class="headerlink" title="不在范围内的用途"></a>不在范围内的用途</h3><ul><li>用于违反适用法律法规（包括贸易合规法）的任何方式。</li><li>用于除英语以外的其他语言。</li><li>用于 Llama 2 可接受使用政策和许可协议所禁止的任何其他方式。</li></ul><h2 id="硬件和软件"><a href="#硬件和软件" class="headerlink" title="硬件和软件"></a>硬件和软件</h2><h3 id="训练因素"><a href="#训练因素" class="headerlink" title="训练因素"></a>训练因素</h3><p>我们使用自定义训练库、Meta 的 Research Super Cluster 以及生产集群进行预训练。微调、标注和评估也是在第三方云计算上执行的。</p><h3 id="碳足迹"><a href="#碳足迹" class="headerlink" title="碳足迹"></a>碳足迹</h3><p>预训练过程中使用了累计 330 万 GPU 小时的计算，使用的硬件类型为 A100-80GB（TDP 为 350-400W）。预计总排放量为 539 tCO2eq，其中 100% 由 Meta 的可持续性计划抵消。</p><table><thead><tr><th>模型</th><th>时间（GPU 小时）</th><th>功耗（瓦）</th><th>排放碳量（tCO2eq）</th></tr></thead><tbody><tr><td>Llama 2 7B</td><td>184,320</td><td>400</td><td>31.22</td></tr><tr><td>Llama 2 13B</td><td>368,640</td><td>400</td><td>62.44</td></tr><tr><td>Llama 2 70B</td><td>1,720,320</td><td>400</td><td>291.42</td></tr><tr><td>总计</td><td>3,311,616</td><td></td><td>539.00</td></tr></tbody></table><p>预训练期间的二氧化碳排放量。时间：每个模型训练所需的总 GPU 时间。功耗：用于所使用的 GPU 设备的每个 GPU 的峰值功率容量，调整后的</p><p>功耗使用效率。100% 的排放直接由 Meta 的可持续性计划抵消，因为我们正在公开发布这些模型，预训练成本不需要由他人承担。</p><h2 id="训练数据-1"><a href="#训练数据-1" class="headerlink" title="训练数据"></a>训练数据</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Llama 2 在来自公开来源的数据中预训练了 2 万亿个 tokens。微调数据包括公开可用的指导数据集，以及一百万个新的人工标注示例。预训练和微调数据集均不包含 Meta 用户数据。</p><h3 id="数据新鲜度"><a href="#数据新鲜度" class="headerlink" title="数据新鲜度"></a>数据新鲜度</h3><p>预训练数据截止日期为 2022 年 9 月，但一些微调数据更近，最多至 2023 年 7 月。</p><h2 id="评估结果"><a href="#评估结果" class="headerlink" title="评估结果"></a>评估结果</h2><p>在此部分，我们报告了 Llama 1 和 Llama 2 模型在标准学术基准测试上的结果。对于所有评估，我们使用我们的内部评估库。</p><table><thead><tr><th>模型</th><th>规模</th><th>Code</th><th>常识推理</th><th>世界知识</th><th>阅读理解</th><th>数学</th><th>MMLU</th><th>BBH</th><th>AGI Eval</th></tr></thead><tbody><tr><td>Llama 1</td><td>7B</td><td>14.1</td><td>60.8</td><td>46.2</td><td>58.5</td><td>6.95</td><td>35.1</td><td>30.3</td><td>23.9</td></tr><tr><td>Llama 1</td><td>13B</td><td>18.9</td><td>66.1</td><td>52.6</td><td>62.3</td><td>10.9</td><td>46.9</td><td>37.0</td><td>33.9</td></tr><tr><td>Llama 1</td><td>33B</td><td>26.0</td><td>70.0</td><td>58.4</td><td>67.6</td><td>21.4</td><td>57.8</td><td>39.8</td><td>41.7</td></tr><tr><td>Llama 1</td><td>65B</td><td>30.7</td><td>70.7</td><td>60.5</td><td>68.6</td><td>30.8</td><td>63.4</td><td>43.5</td><td>47.6</td></tr><tr><td>Llama 2</td><td>7B</td><td>16.8</td><td>63.9</td><td>48.9</td><td>61.3</td><td>14.6</td><td>45.3</td><td>32.6</td><td>29.3</td></tr><tr><td>Llama 2</td><td>13B</td><td>24.5</td><td>66.9</td><td>55.4</td><td>65.8</td><td>28.7</td><td>54.8</td><td>39.4</td><td>39.1</td></tr><tr><td>Llama 2</td><td>70B</td><td>37.5</td><td>71.9</td><td>63.6</td><td>69.4</td><td>35.2</td><td>68.9</td><td>51.2</td><td>54.2</td></tr></tbody></table><p>模型在 grouped academic benchmarks 上的整体表现。Code：我们报告模型在 HumanEval 和 MBPP 上的平均 pass@1 分数。常识推理：我们报告 PIQA、SIQA、HellaSwag、WinoGrande、ARC easy 和 challenge、OpenBookQA 和 CommonsenseQA 的平均分数。我们对 CommonSenseQA 进行了 7-shot 结果评估，对其他所有基准测试进行了 0-shot 结果评估。世界知识：我们在 NaturalQuestions 和 TriviaQA 上进行 5-shot 性能评估并报告平均分数。阅读理解：对于阅读理解，我们报告 SQuAD、QuAC 和 BoolQ 的 0-shot 平均分数。数学：我们报告 GSM8K（8-shot）和 MATH（4-shot）基准测试的平均分数。</p><h3 id="TruthfulQA-和-Toxigen"><a href="#TruthfulQA-和-Toxigen" class="headerlink" title="TruthfulQA 和 Toxigen"></a>TruthfulQA 和 Toxigen</h3><table><thead><tr><th>模型</th><th>规模</th><th>TruthfulQA</th><th>Toxigen</th></tr></thead><tbody><tr><td>Llama 1</td><td>7B</td><td>27.42</td><td>23.00</td></tr><tr><td>Llama 1</td><td>13B</td><td>41.74</td><td>23.08</td></tr><tr><td>Llama 1</td><td>33B</td><td>44.19</td><td>22.57</td></tr><tr><td>Llama 1</td><td>65B</td><td>48.71</td><td>21.77</td></tr><tr><td>Llama 2</td><td>7B</td><td>33.29</td><td>21.25</td></tr><tr><td>Llama 2</td><td>13B</td><td>41.86</td><td>26.10</td></tr><tr><td>Llama 2</td><td>70B</td><td>50.18</td><td>24.60</td></tr></tbody></table><p>预训练 LLMs 在自动安全基准测试上的评估结果。对于 TruthfulQA，我们呈现同时具有真实性和信息量的生成百分比（百分比越高越好）。对于 ToxiGen，我们呈现有害生成的百分比（百分比越小越好）。</p><h3 id="TruthfulQA-和-Toxigen（微调版本-LLMs）"><a href="#TruthfulQA-和-Toxigen（微调版本-LLMs）" class="headerlink" title="TruthfulQA 和 Toxigen（微调版本 LLMs）"></a>TruthfulQA 和 Toxigen（微调版本 LLMs）</h3><table><thead><tr><th>模型</th><th>规模</th><th>TruthfulQA</th><th>Toxigen</th></tr></thead><tbody><tr><td>Llama-2-Chat</td><td>7B</td><td>57.04</td><td>0.00</td></tr><tr><td>Llama-2-Chat</td><td>13B</td><td>62.18</td><td>0.00</td></tr><tr><td>Llama-2-Chat</td><td>70B</td><td>64.14</td><td>0.01</td></tr></tbody></table><p>不同安全数据集上微调 LLMs 的评估结果。度量标准定义同上。</p><h2 id="道德考虑和局限性"><a href="#道德考虑和局限性" class="headerlink" title="道德考虑和局限性"></a>道德考虑和局限性</h2><p>Llama 2 是一项具有风险的新技术。迄今为止的测试仅涵盖了英语，并且无法覆盖所有场景。因此，与所有 LLMs 一样，Llama 2 的潜在输出无法事先预测，并且在某些情况下可能会产生不准确、带偏见或其他不可取的响应。因此，在部署任何 Llama 2 应用程序之前，开发人员应根据其特定的模型应用进行安全测试和调整。</p><p>请参阅“负责任使用指南”，网址为：<a href="https://ai.meta.com/llama/responsible-use-guide/">https://ai.meta.com/llama/responsible-use-guide/</a></p><h2 id="报告问题"><a href="#报告问题" class="headerlink" title="报告问题"></a>报告问题</h2><p>请通过以下方式之一报告任何软件“bug”或模型的其他问题：</p><ul><li>报告模型问题：[github.com/facebookresearch/llama](<a href="https://github/">https://github</a></li></ul><p>.com/facebookresearch/llama)</p><ul><li>报告模型生成的有问题内容：<a href="https://developers.facebook.com/llama_output_feedback">developers.facebook.com/llama_output_feedback</a></li><li>报告 bug 和安全问题：<a href="https://facebook.com/whitehat/info">facebook.com/whitehat/info</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Training-Llama-2-Model-on-Single-GPU-with-int8-Quantization-and-LoRA&quot;&gt;&lt;a href=&quot;#Training-Llama-2-Model-on-Single-GPU-with-int8-Quant</summary>
      
    
    
    
    <category term="NLP Insights" scheme="https://chenhuiyu.github.io/categories/NLP-Insights/"/>
    
    
    <category term="LLM" scheme="https://chenhuiyu.github.io/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>LONGNET - Scaling Transformers to 1,000,000,000 Tokens</title>
    <link href="https://chenhuiyu.github.io/2023/07/28/NLP%20Insights/LONGNET/"/>
    <id>https://chenhuiyu.github.io/2023/07/28/NLP%20Insights/LONGNET/</id>
    <published>2023-07-28T06:43:10.000Z</published>
    <updated>2023-07-31T10:56:02.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LONGNET：将Transformer扩展到10亿个标记"><a href="#LONGNET：将Transformer扩展到10亿个标记" class="headerlink" title="LONGNET：将Transformer扩展到10亿个标记"></a>LONGNET：将Transformer扩展到10亿个标记</h1><p>在本篇文章中，我们将详细讨论一个近期发布的先进模型——“LongNet”。该模型由微软亚洲研究院研发，于大约两周前正式公布。LongNet基于Transformer模型构建，其核心理念在于拓展Transformer的应用规模。值得一提的是，研究团队成功地将其扩展至处理10亿个令牌的规模。对于熟悉语言模型的人来说，会明白序列长度对模型性能的影响，因为序列长度决定了在执行注意力机制时，能够关联的令牌数量，从而影响模型可以获取的上下文信息长度。例如，我们希望像GPT这样的模型能拥有更长的上下文，使得模型可以参考更久之前的单词来预测下一个令牌。而LongNet就成功地将这个能力扩展到了10亿个令牌。以下图为例，可以清晰看出，GPT的序列长度仅为512，而Power Transformer的序列长度可扩展至12、000、64、262、000、甚至1000万，然而LongNet将序列长度扩展至惊人的10亿个令牌。试想一下，我们可以将所有维基百科的文本信息输入到模型中，模型可以利用所有这些令牌进行注意力计算。接下来，让我们首先来了解一下LongNet的工作原理。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在大型语言模型时代，扩展序列长度已成为一个重要需求。然而，现有方法在处理计算复杂性或模型表达能力时遇到困难，导致最大序列长度受限。为了解决这个问题，我们引入了LONGNET，这是一种Transformer变体，可以将序列长度扩展到10亿个标记以上，同时不损害对较短序列的性能。具体而言，我们提出了扩张注意力（dilated attention），随着距离增加，它以指数级扩展注意力范围。LONGNET有显著的优势：1）它具有线性计算复杂性，并且序列中任意两个标记之间存在对数依赖关系；2）它可以作为分布式训练器用于非常长的序列；3）它的扩张注意力可以无缝替换标准注意力，并且可以与现有基于Transformer的优化方法无缝集成。实验结果表明，LONGNET在长序列建模和一般语言任务上表现出强大的性能。我们的工作为建模非常长的序列打开了新的可能性，例如将整个语料库甚至整个互联网视为一个序列。</p><img src="/2023/07/28/NLP%20Insights/LONGNET/Figure_1.png" class="" title="Figure 1: Trend of Transformer sequence lengths over time."><h3 id="LongNet的优点"><a href="#LongNet的优点" class="headerlink" title="LongNet的优点"></a>LongNet的优点</h3><p>LongNet具有多种优点。首先，其计算复杂度与序列长度呈线性关系，稍后将具体解释原因。其次，令牌之间存在对数依赖，也就是说，两个距离较远的令牌之间的依赖性较弱，而距离较近的令牌之间的依赖性较强。此外，它可在分布式网络中进行训练，这意味着我们可以利用分布式系统计算该注意力机制，如使用多个GPU或多台计算机。同时，LongNet可以作为标准注意力的替代品，这意味着如果我们已经有一个使用注意力机制的模型，我们只需将注意力机制替换为LongNet的机制，无需改变模型的其他部分，模型仍然能够像以前一样运行，但通过使用这种改进的注意力机制，可以处理更长的序列长度。</p><h3 id="关于Transformer模型的梳理"><a href="#关于Transformer模型的梳理" class="headerlink" title="关于Transformer模型的梳理"></a>关于Transformer模型的梳理</h3><p>自注意力机制，我们使用了被称为“Q、K、V”的矩阵。其中，“Q”矩阵代表查询，其规模为“序列长度乘以模型大小”，模型大小指的是每个词嵌入的向量表示。当我们计算查询与键（K）的乘积，或者查询与K的转置的乘积来产生此矩阵时，所需的操作次数是“序列长度的平方乘以模型大小”，因为我们需要为矩阵中的每个元素计算点积。这就是为什么自注意力的复杂度是“序列长度的平方乘以模型大小”。这个比较在相关论文中也有详细描述，常规的注意力复杂度是“序列长度的平方乘以模型大小”，然而LongNet这种新模型，其注意力机制复杂度仅为“序列长度乘以模型大小”，下文我将说明如何实现这种线性复杂度。</p><img src="/2023/07/28/NLP%20Insights/LONGNET/image-5.png" class="" title="Figure 2"><h3 id="LongNet的注意力分配原理"><a href="#LongNet的注意力分配原理" class="headerlink" title="LongNet的注意力分配原理"></a>LongNet的注意力分配原理</h3><p>LongNet的核心原理是，令牌间的注意力分配会随着它们之间距离的增加而呈指数级地减小。让我们参照图表来理解它的运作方式。在传统方式中，我们计算所有令牌与其他所有令牌之间的注意力，但LongNet并未如此操作。它采用了一种将序列切分为不同大小窗口的方法。首先，以4为窗口大小为例，这里的“N”是序列的令牌数，我们将其分成四个大小为4的段，并计算这个小窗口内的所有词与其他词之间的注意力。然后，我们对所有这些小段中的词执行同样的操作，接着使用更大的窗口，这次窗口大小为8。如此类推，直到覆盖整个序列长度，然后我们再以增加窗口大小的方式进行操作，同时我们也增加了跳过的令牌数，即“R”。例如，我们可以先计算大小为8的窗口，然后将“R”设为2，这意味着我们会跳过一个令牌，然后计算注意力，再跳过一个令牌，继续计算注意力。以这种方式，随着窗口大小和跳过的令牌数的增加，计算的复杂度变得更小，因为我们并不是计算每个令牌与所有其他令牌之间的注意力，而是只计算在有限范围内的注意力。这样，LongNet的注意力分配就遵循了对数依赖的原则，即，距离较远的令牌之间的依赖性较弱，而距离较近的令牌之间的依赖性较强。这是LongNet能在更大序列长度上进行工作的关键。<br>扩展注意力由一系列用于建模短程和长程依赖关系的注意力模式组成，注意力模式的数量可以根据序列长度进行扩展。在每个注意力模式中，查询向量和键向量之间的点积被分解为多个子点积，每个子点积仅涉及到一小部分的键向量。这种分解方式可以减少计算复杂度，同时也可以使模型更好地处理长序列。具体如下图所示：</p><img src="/2023/07/28/NLP%20Insights/LONGNET/image.png" class="" title="Figure 3"><img src="/2023/07/28/NLP%20Insights/LONGNET/image-4.png" class="" title="Figure 4"><p>扩张注意力还引入了“多头”机制，可以在不同的头之间分别计算注意力。每个头都有自己的偏移量，这样就可以在不同的位置上计算注意力，从而更好地捕捉序列中的信息。通过这种方式，扩张注意力可以更好地处理长序列，同时保持较短序列的性能。具体如下图所示：</p><img src="/2023/07/28/NLP%20Insights/LONGNET/image-4.png" class="" title="Figure 5"><h3 id="计算复杂度的优化"><a href="#计算复杂度的优化" class="headerlink" title="计算复杂度的优化"></a>计算复杂度的优化</h3><p>现在我们来看看为什么LongNet的计算复杂度是线性的。在传统的自注意力机制中，我们需要执行序列长度平方次数的点积操作，而LongNet通过使用窗口和跳过的方式，将计算的复杂度降低到了线性。如果我们假设窗口大小是固定的，例如为4，然后“R”也是固定的，例如为2，那么计算复杂度将是“O(N)”。当然，在实际操作中，窗口大小和跳过的令牌数可能会根据实际情况进行调整，但是它们是常数，不随序列长度增加而增加。这就是为什么LongNet的计算复杂度是线性的。</p><img src="/2023/07/28/NLP%20Insights/LONGNET/image-3.png" class="" title="Figure 6"><h3 id="Token扩展10亿"><a href="#Token扩展10亿" class="headerlink" title="Token扩展10亿+"></a>Token扩展10亿+</h3><p>分布式训练方法，利用LONGNET的线性计算复杂度，将序列维度分布式地进行训练。具体而言，算法首先将输入序列沿着序列维度进行切分，每个序列片段被分配到不同的设备上进行计算。然后，每个设备将序列片段投影为查询、键和值，并使用本地计算得到局部的注意力权重。对于超出本地设备序列长度的部分，键和值将被发送到其他设备上进行计算。最后，所有设备将局部的注意力权重进行汇总，得到全局的注意力权重，并使用全局的注意力权重计算每个标记的表示。具体如下图所示：</p><img src="/2023/07/28/NLP%20Insights/LONGNET/image-2.png" class="" title="Figure 7"><p>该算法可以在任意数量的设备上进行扩展，并且可以通过并行计算来加速训练过程。由于LONGNET具有线性计算复杂度，因此该算法可以有效地处理超长序列，而不会牺牲训练速度和模型性能。此外，该算法还支持标准Transformer的优化技术，例如内核融合、量化和分布式训练，从而使得LONGNET可以无缝地与现有的深度学习框架进行集成。</p><h3 id="LongNet的应用前景"><a href="#LongNet的应用前景" class="headerlink" title="LongNet的应用前景"></a>LongNet的应用前景</h3><p>LongNet的发布为自然语言处理领域带来了诸多潜在的应用前景。首先，它可以应用于更长文本的生成任务，如生成长篇小说或长篇新闻报道。其次，它可以应用于更复杂的对话任务，因为在对话中，我们往往需要处理大量的历史信息和上下文。另外，它还可能在翻译任务中发挥更大的作用，因为翻译往往涉及到处理长句子或长段落的情况。总的来说，LongNet的发布为我们提供了处理更长文本的新工具和可能性。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>总的来说，LongNet是一个基于Transformer的模型，它成功地将自注意力机制扩展到了10亿个令牌，实现了处理更长文本的能力。它的优势包括计算复杂度是线性的、遵循对数依赖原则，以及可以在分布式系统上进行训练。通过LongNet，我们可以探索更多自然语言处理任务，并处理那些过去由于序列长度限制而难以处理的任务。这个新模型的发布为我们带来了更多可能性。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://arxiv.org/pdf/2307.02486.pdf">LONGNET: Scaling Transformers to 1,000,000,000 Tokens</a></li><li><a href="https://www.youtube.com/watch?v=nC2nU9j9DVQ">Youtube Tutorial by Umar Jamil</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LONGNET：将Transformer扩展到10亿个标记&quot;&gt;&lt;a href=&quot;#LONGNET：将Transformer扩展到10亿个标记&quot; class=&quot;headerlink&quot; title=&quot;LONGNET：将Transformer扩展到10亿个标记&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="NLP Insights" scheme="https://chenhuiyu.github.io/categories/NLP-Insights/"/>
    
    
    <category term="LLM" scheme="https://chenhuiyu.github.io/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>Prompt Engineering</title>
    <link href="https://chenhuiyu.github.io/2023/07/27/NLP%20Insights/Prompt%20Engineering/"/>
    <id>https://chenhuiyu.github.io/2023/07/27/NLP%20Insights/Prompt%20Engineering/</id>
    <published>2023-07-27T07:44:10.000Z</published>
    <updated>2023-07-27T07:55:50.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Prompt-Engineering"><a href="#Prompt-Engineering" class="headerlink" title="Prompt Engineering"></a>Prompt Engineering</h1><p>Prompt Engineering, 也被称为上下文提示，是指在不更新模型权重的情况下，与LLM（语言模型）进行交互以引导其产生期望输出的方法。它是一门实证科学，提示工程方法的效果在不同模型之间可能会有很大的差异，因此需要进行大量的实验和试探。</p><p>本文仅关注自回归语言模型的提示工程，不涉及填空测试、图像生成或多模态模型。在本质上，提示工程的目标是实现模型的对齐和可操控性。您可以查阅我之前关于可控文本生成的帖子。</p><h2 id="基本提示方法"><a href="#基本提示方法" class="headerlink" title="基本提示方法"></a>基本提示方法</h2><p>zero-shot学习和few-shot学习是两种最基本的提示模型方法，这些方法由许多LLM论文首创，并且通常用于评估LLM性能。</p><h3 id="zero-shot学习"><a href="#zero-shot学习" class="headerlink" title="zero-shot学习"></a>zero-shot学习</h3><p>zero-shot学习是将任务文本直接输入模型并要求获得结果。</p><p>（所有情感分析示例来自于SST-2数据集）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Text: i'll bet the video game is a lot more fun than the film.</span><br><span class="line">Sentiment:</span><br></pre></td></tr></tbody></table></figure><h3 id="few-shot学习"><a href="#few-shot学习" class="headerlink" title="few-shot学习"></a>few-shot学习</h3><p>few-shot学习通过提供一组高质量的示例演示，每个示例都包含目标任务的输入和期望输出。当模型首先看到好的示例时，它可以更好地理解人类的意图和期望的答案类型。因此，few-shot学习通常比zero-shot学习表现更好。然而，这样做的代价是更多的记号消耗，并且在输入和输出文本较长时可能会达到上下文长度限制。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Text: (lawrence bounces) all over the stage, dancing, running, sweating, mopping his face and generally displaying the wacky talent that brought him fame in the first place.</span><br><span class="line">Sentiment: positive</span><br><span class="line"></span><br><span class="line">Text: despite all evidence to the contrary, this clunker has somehow managed to pose as an actual feature movie, the kind that charges full admission and gets hyped on tv and purports to amuse small children and ostensible adults.</span><br><span class="line">Sentiment: negative</span><br><span class="line"></span><br><span class="line">Text: for the first time in years, de niro digs deep emotionally, perhaps because he's been stirred by the powerful work of his co-stars.</span><br><span class="line">Sentiment: positive</span><br><span class="line"></span><br><span class="line">Text: i'll bet the video game is a lot more fun than the film.</span><br><span class="line">Sentiment:</span><br></pre></td></tr></tbody></table></figure><p>许多研究都探讨了如何构建上下文示例以最大化性能，并观察到提示格式、训练示例和示例的顺序选择可能会导致截然不同的性能，从几乎随机猜测到接近SOTA（State-of-the-Art）。</p><p>赵等人（2021年）研究了few-shot分类的情况，并提出了一些与LLM（他们在实验中使用了GPT-3）相关的偏差，这些偏差导致了高方差的情况：</p><ul><li>（1）多数类别偏差存在于示例的标签分布不平衡的情况下；</li><li>（2）最近偏差是指模型可能在结尾重复标签；</li><li>（3）常见记号偏差表明LLM倾向于更频繁地生成常见的记号而不是罕见的记号。为了克服这些偏差，他们提出了一种方法，通过对模型输出的标签概率进行校准，使其在输入字符串为N/A时保持均匀。</li></ul><h2 id="提示工程技巧"><a href="#提示工程技巧" class="headerlink" title="提示工程技巧"></a>提示工程技巧</h2><h3 id="示例选择的建议"><a href="#示例选择的建议" class="headerlink" title="示例选择的建议"></a>示例选择的建议</h3><ul><li><p>使用嵌入空间中的NN聚类（Liu等人，2021年）来选择与测试示例在语义上相似的示例。</p></li><li><p>Su等人（2022年）提出了一种基于图的方法来选择多样且代表性的示例：</p><ol><li>首先，根据样本之间的嵌入（例如SBERT或其他嵌入模型）余弦相似性构建一个有向图，其中每个节点指向其最近的邻居；</li><li>开始时有一组已选择的示例和一组剩余示例。每个示例都通过得分函数进行评分，其中得分函数的目标是保持低值，以鼓励选择多样化的示例。具体得分函数的计算公式未提供。</li></ol></li><li><p>Rubin等人（2022年）提出了针对上下文学习示例选择的对比学习方法。对于每个训练对（格式化的输入-输出对），可以通过LM分配的条件概率来衡量一个示例的质量。然后，可以根据得分对训练对进行排名，选择得分较高和得分较低的示例作为对比学习的正样本和负样本集。</p></li><li><p>有些研究人员尝试使用Q-Learning进行示例选择（Zhang等人，2022年）。</p></li><li><p>受不确定性主导的主动学习的启发，Diao等人（2023年）建议确定具有多次采样试验中高度不一致或熵值较高的示例，并注释这些示例以在few-shot提示中使用。</p></li></ul><h3 id="示例排序的建议"><a href="#示例排序的建议" class="headerlink" title="示例排序的建议"></a>示例排序的建议</h3><ul><li><p>一般建议保持示例选择的多样性，与测试示例相关，并以随机顺序进行排列，以避免多数类别偏差和最近偏差。</p></li><li><p>增加模型大小或包含更多训练示例并不能减少上下文示例不同排列之间的方差。同一顺序对一个模型可能有效，但对另一个模型可能无效。当验证集有限时，可以考虑选择顺序，以使模型不会产生极端不平衡的预测或对其预测过于自信（Lu等人，2022年）。</p></li></ul><h2 id="指令提示"><a href="#指令提示" class="headerlink" title="指令提示"></a>指令提示</h2><ul><li><p>在提示中展示few-shot示例的目的是向模型解释我们的意图；换句话说，用示例来描述任务指令，以便模型能够理解用户意图并遵循指令。然而，few-shot的使用可能会消耗较多的记号，并限制输入长度，因为上下文长度有限。所以，为什么不直接给出指令呢？</p></li><li><p>Instructed LM（例如InstructGPT，自然语言指令）使用高质量的（任务指令，输入，真实输出）元组对预训练模型进行微调，以使LM更好地理解用户意图并遵循指令。RLHF（人类反馈的强化学习）是一种常见的方法。采用指令遵循风格的微调使得模型更加符合人类意图，并极大地降低了通信成本。</p></li><li><p>在与指令模型进行交互时，我们应该详细描述任务要求，尽量具体和准确，并避免使用”不做某事”的表述，而是要明确指定要做什么。</p></li></ul><h1 id="Chain-of-Thought-CoT-Prompting"><a href="#Chain-of-Thought-CoT-Prompting" class="headerlink" title="Chain-of-Thought (CoT) Prompting"></a>Chain-of-Thought (CoT) Prompting</h1><p>Chain-of-Thought (CoT) Prompting（Wei等人，2022年）通过生成一系列简短的句子，逐步描述推理逻辑，即所谓的推理链或理由链，最终引导出最终答案。CoT在复杂的推理任务中效果更显著，特别是在使用大型模型（例如超过50亿参数的模型）时。对于简单的任务，CoT提示的受益较小。</p><p>CoT提示的两种主要类型：</p><h2 id="few-shot-CoT"><a href="#few-shot-CoT" class="headerlink" title="few-shot CoT"></a>few-shot CoT</h2><p>few-shot CoT是使用少量演示来引导模型，每个演示包含人工编写（或模型生成）的高质量推理链。</p><p>（以下所有数学推理示例来自GSM8k数据集）</p><p>问题：Tom和Elizabeth比赛爬山。Elizabeth花了30分钟爬上山。Tom花费的时间是Elizabeth的四倍。Tom爬上山需要多少小时？</p><p>答案：Tom需要30 * 4 = 120分钟爬上山。<br>Tom需要120/60 = 2小时爬上山。<br>所以答案是2。</p><p>===</p><p>问题：Jack是个足球运动员。他需要买两双袜子和一双足球鞋。每双袜子的价格是9.50美元，鞋子的价格是92美元。Jack有40美元。Jack还需要多少钱？</p><p>答案：两双袜子的总费用是9.50美元 x 2 = 19美元。<br>袜子和鞋子的总费用是19美元 + 92美元 = 111美元。<br>Jack还需要111美元 - 40美元 = 71美元。<br>所以答案是71。</p><p>===</p><p>问题：Marty有100厘米的缎带，他必须将其分成4等份。每个切割部分必须再分成5等份。每个最终切割部分将有多长？</p><p>答案：（待填写）</p><h2 id="zero-shot-CoT"><a href="#zero-shot-CoT" class="headerlink" title="zero-shot CoT"></a>zero-shot CoT</h2><p>zero-shot CoT是使用自然语言陈述，例如“让我们逐步思考”，明确地鼓励模型首先生成推理链，然后再通过“因此，答案是”等提示来产生答案（Kojima等人，2022年）。或者使用类似的语句“让我们一步一步来计算，确保我们得到正确的答案”（Zhou等人，2022年）。</p><p>问题：Marty有100厘米的缎带，他必须将其分成4等份。每个切割部分必须再分成5等份。每个最终切割部分将有多长？</p><p>答案：让我们逐步思考。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@article{weng2023prompt,</span><br><span class="line">  title   = "Prompt Engineering",</span><br><span class="line">  author  = "Weng, Lilian",</span><br><span class="line">  journal = "lilianweng.github.io",</span><br><span class="line">  year    = "2023",</span><br><span class="line">  month   = "Mar",</span><br><span class="line">  url     = "https://lilianweng.github.io/posts/2023-03-15-prompt-engineering/"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Prompt-Engineering&quot;&gt;&lt;a href=&quot;#Prompt-Engineering&quot; class=&quot;headerlink&quot; title=&quot;Prompt Engineering&quot;&gt;&lt;/a&gt;Prompt Engineering&lt;/h1&gt;&lt;p&gt;Prompt</summary>
      
    
    
    
    <category term="NLP Insights" scheme="https://chenhuiyu.github.io/categories/NLP-Insights/"/>
    
    
    <category term="LLM" scheme="https://chenhuiyu.github.io/tags/LLM/"/>
    
    <category term="Prompt" scheme="https://chenhuiyu.github.io/tags/Prompt/"/>
    
  </entry>
  
</feed>
